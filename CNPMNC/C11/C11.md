Chào bạn, đây là một chiến lược rất thông minh. Môn "Công nghệ phần mềm" (Software Engineering) phần Reliability (Độ tin cậy) thường có nhiều khái niệm trừu tượng và các chỉ số tính toán dễ gây nhầm lẫn.

Vì bạn được mang tài liệu vào phòng thi, tôi sẽ giải thích chi tiết theo từng nhóm slide (vì một số slide nối tiếp nội dung nhau) và **nhấn mạnh các từ khóa (keywords)** hoặc **các bẫy** mà đề thi thường ra để bạn có thể ghi chú trực tiếp vào tài liệu của mình.

Dưới đây là phần giải thích chi tiết cho **40 slide đầu tiên** (Nửa đầu của tài liệu).

---

### **PHẦN 1: KHÁI NIỆM CƠ BẢN VỀ ĐỘ TIN CẬY (Slide 1 - 16)**

#### **Slide 1-2: Giới thiệu & Các chủ đề bao phủ**
*   **Nội dung:** Giới thiệu chương và danh sách các chủ đề.
*   **Điểm cần nhớ:** Nhìn vào Slide 2 để biết bản đồ tư duy của chương này. Gồm 5 phần chính:
    1.  Khái niệm Availability (Tính sẵn sàng) và Reliability (Độ tin cậy).
    2.  Các yêu cầu về độ tin cậy.
    3.  Kiến trúc chịu lỗi (Fault-tolerant).
    4.  Lập trình để đạt độ tin cậy.
    5.  Đo lường độ tin cậy.

#### **Slide 3: Software Reliability (Độ tin cậy phần mềm)**
*   **Giải thích:**
    *   Khách hàng luôn muốn phần mềm chạy tốt. Nhưng với phần mềm **không quan trọng** (ví dụ: game, app giải trí), lỗi một chút cũng chấp nhận được.
    *   Với **hệ thống quan trọng (Critical systems)** như y tế, viễn thông, hàng không: Bắt buộc độ tin cậy phải rất cao vì sai sót dẫn đến chết người hoặc thiệt hại kinh tế lớn.
*   **Ghi chú thi:** Phân biệt được *Critical* và *Non-critical systems*.

#### **Slide 4-5: Faults, Errors và Failures (Rất quan trọng - Hay thi)**
*   **Giải thích chuỗi phản ứng:**
    1.  **Human Error/Mistake (Sai lầm của con người):** Lập trình viên tư duy sai (ví dụ: quên tính trường hợp qua nửa đêm).
    2.  **System Fault (Lỗi/Khuyết điểm hệ thống):** Sai lầm đó biến thành dòng code sai (bug) nằm trong source code.
    3.  **System Error (Lỗi trạng thái):** Khi chạy đến dòng code sai đó, hệ thống rơi vào trạng thái sai (ví dụ: biến thời gian = 24.00 thay vì 00.00).
    4.  **System Failure (Hư hỏng/Thất bại):** Hệ thống sập hoặc đưa ra kết quả sai cho người dùng (ví dụ: không gửi được dữ liệu thời tiết).
*   **Slide 5 nhấn mạnh:**
    *   Có *Fault* chưa chắc dẫn đến *Error* (nếu dòng code đó không bao giờ chạy tới).
    *   Có *Error* chưa chắc dẫn đến *Failure* (nếu hệ thống có cơ chế tự sửa lỗi trước khi người dùng nhận ra).
*   **Mẹo thi:** Đề có thể cho một tình huống và hỏi đâu là Fault, đâu là Failure.
    *   *Fault:* Code sai (tĩnh).
    *   *Failure:* Hành vi sai lệch so với mong đợi (động).

#### **Slide 6-7: Fault Management (Quản lý lỗi)**
Ba cách để xử lý lỗi (thứ tự ưu tiên từ lúc làm đến lúc chạy):
1.  **Fault Avoidance (Tránh lỗi):** Code kỹ, quy trình chuẩn để không tạo ra bug ngay từ đầu.
2.  **Fault Detection (Phát hiện lỗi):** Testing (kiểm thử) để tìm và sửa lỗi trước khi giao cho khách.
3.  **Fault Tolerance (Chịu lỗi):** Hệ thống vẫn chạy được ngay cả khi có lỗi xảy ra (ví dụ: máy bay có 2 động cơ, hỏng 1 cái vẫn bay được).

#### **Slide 8: Chi phí loại bỏ lỗi**
*   **Biểu đồ:** Càng muốn loại bỏ những lỗi cuối cùng (để đạt độ tin cậy 100%), chi phí càng tăng vọt theo hình parabol.
*   **Ý nghĩa:** Không thể nào loại bỏ 100% lỗi vì quá tốn kém. Phải chấp nhận một mức "lỗi còn sót lại" chấp nhận được.

#### **Slide 9-10: Availability và Reliability (Định nghĩa - Hay thi)**
*   **Reliability (Độ tin cậy):** Xác suất hệ thống chạy **không bị lỗi** trong một khoảng thời gian nhất định. (Quan tâm đến việc: *Chạy liên tục bao lâu thì chết?*).
*   **Availability (Tính sẵn sàng):** Xác suất hệ thống **đang hoạt động** tại một thời điểm bất kỳ khi người dùng cần. (Quan tâm đến việc: *Lúc tôi cần dùng thì nó có sống không?*).
*   **Ví dụ:** Một server bị sập 1 lần mỗi giờ (Reliability thấp), nhưng tự khởi động lại trong 1 giây (Availability rất cao vì thời gian chết quá ngắn).

#### **Slide 11-12: Đặc tả và Cảm nhận**
*   **Vấn đề:**
    *   Định nghĩa "Reliability" dựa trên đặc tả kỹ thuật (Specification). Nếu code chạy đúng spec nhưng spec viết sai -> Người dùng vẫn coi là Failure.
    *   Người dùng không đọc spec, họ chỉ quan tâm hệ thống có làm việc họ cần hay không.
*   **Slide 12:** Môi trường và Hậu quả ảnh hưởng đến cảm nhận. (Ví dụ: Gạt nước xe hơi bị hư ở sa mạc -> Không ai quan tâm -> Cảm giác vẫn tin cậy. Nhưng hư ở trời mưa -> Rất tệ).

#### **Slide 13-16: Mô hình Input/Output và Thói quen sử dụng**
*   **Slide 13:** Hệ thống như một hộp đen ánh xạ Input -> Output. Một số Input rơi vào vùng lỗi ($I_e$) sẽ tạo ra Output lỗi ($O_e$).
*   **Slide 16 (Quan trọng):**
    *   Sửa 50% số lỗi (bugs) chưa chắc làm tăng độ tin cậy thêm 50%.
    *   Lý do: Nếu bạn sửa những lỗi nằm trong phần code mà người dùng **hiếm khi dùng tới**, thì người dùng sẽ không cảm thấy phần mềm tốt lên chút nào.
    *   **Kết luận:** Phải tập trung sửa lỗi ở những chức năng được dùng thường xuyên nhất.

---

### **PHẦN 2: YÊU CẦU VỀ ĐỘ TIN CẬY (Slide 17 - 32)**

#### **Slide 17-18: Phân loại yêu cầu**
*   **Functional Reliability Requirements (Yêu cầu chức năng):** Hệ thống phải **làm gì** để tránh lỗi? (Ví dụ: Hệ thống phải kiểm tra mật khẩu, phải có tường lửa...).
*   **Non-functional Reliability Requirements (Yêu cầu phi chức năng):** Các con số định lượng. (Ví dụ: Hệ thống không được sập quá 1 lần/năm).

#### **Slide 19: Các chỉ số đo lường (Metrics)**
Để đo độ tin cậy, ta cần đếm số lần thất bại (Failures). Có 3 chỉ số chính:
1.  POFOD
2.  ROCOF / MTTF
3.  Availability

#### **Slide 20: POFOD (Probability of Failure on Demand)**
*   **Định nghĩa:** Xác suất bị lỗi khi có một yêu cầu được gửi đến.
*   **Công thức:** $POFOD = 0.001$ nghĩa là cứ 1000 lần yêu cầu thì có 1 lần thất bại.
*   **Dùng khi nào?** Dùng cho các hệ thống **ít khi chạy nhưng chạy là phải đúng** (Hệ thống bảo vệ, phanh khẩn cấp, kích hoạt túi khí).

#### **Slide 21: ROCOF và MTTF**
*   **ROCOF (Rate of Occurrence of Failures):** Tần suất lỗi (ví dụ: 2 lỗi/1000 giờ). Dùng cho hệ thống xử lý giao dịch liên tục (ngân hàng, đặt vé).
*   **MTTF (Mean Time To Failure):** Thời gian trung bình giữa các lần lỗi. Là nghịch đảo của ROCOF. Dùng cho hệ thống chạy các tác vụ dài (ví dụ: Render video mất 3 ngày, thì MTTF phải lớn hơn 3 ngày).

#### **Slide 22-23: Availability (Tính sẵn sàng)**
*   **Công thức:** Tính bằng % thời gian hệ thống hoạt động.
    *   Availability 0.999 (3 số 9) = Chết 8.76 giờ/năm.
    *   Availability 0.99999 (5 số 9 - chuẩn viễn thông) = Chết khoảng 5 phút/năm.
*   **Khác biệt với Reliability:** Availability tính cả thời gian sửa chữa (Repair time). Nếu sửa cực nhanh, Availability sẽ cao.
*   **Dùng cho:** Hệ thống chạy 24/7 (tổng đài điện thoại, đèn giao thông).

#### **Slide 27-29: Ví dụ về ATM (Case Study)**
*   Phân tích máy ATM:
    *   Cần **Availability** cao (để khách lúc nào đến rút cũng được).
    *   Tuy nhiên, phần mềm ATM máy lẻ có thể chấp nhận độ sẵn sàng thấp hơn Database trung tâm. Nếu Database chết, toàn bộ hệ thống ATM chết -> Database cần Availability cực cao (0.9999).

#### **Slide 30: Ví dụ về Bơm Insulin (Case Study)**
*   Phân tích máy bơm thuốc cho bệnh nhân tiểu đường:
    *   Cần **Reliability (POFOD)** thấp (nghĩa là xác suất lỗi phải cực thấp).
    *   Lỗi thoáng qua (Transient): Người dùng có thể reset (POFOD 0.002 chấp nhận được).
    *   Lỗi vĩnh viễn (Permanent): Hư hẳn máy -> Nguy hiểm tính mạng -> POFOD phải cực nhỏ (0.00002).

#### **Slide 31-32: Ví dụ về Yêu cầu chức năng**
Các từ khóa để viết yêu cầu:
*   **Checking (Kiểm tra):** Phát hiện input sai.
*   **Recovery (Khôi phục):** Tự sửa sau khi lỗi.
*   **Redundancy (Dư thừa):** Có bản sao lưu.
*   **Process (Quy trình):** Yêu cầu về cách làm việc (ví dụ: phải dùng ngôn ngữ Ada).

---

### **PHẦN 3: KIẾN TRÚC CHỊU LỖI - FAULT TOLERANCE (Slide 33 - 40)**

#### **Slide 33-35: Tổng quan về Fault Tolerance**
*   **Mục tiêu:** Hệ thống vẫn chạy tiếp dù có lỗi xảy ra.
*   **Nguyên lý cốt lõi:** Dựa vào **Redundancy (Dư thừa)** và **Diversity (Đa dạng)**.
    *   *Redundancy:* Có nhiều hơn 1 cái (2 máy tính, 2 server).
    *   *Diversity:* Các cái đó phải khác nhau (khác phần cứng, khác người code) để không bị chết cùng một lỗi giống nhau.

#### **Slide 36-38: Protection Systems (Hệ thống bảo vệ)**
*   **Định nghĩa:** Là một hệ thống riêng biệt, chuyên giám sát hệ thống chính.
*   **Cơ chế:** Nếu hệ thống chính hoạt động vượt ngưỡng an toàn (ví dụ: nhiệt độ lò phản ứng quá cao), hệ thống bảo vệ sẽ chiếm quyền và tắt máy khẩn cấp.
*   **Đặc điểm:** Phải đơn giản, độc lập và có độ tin cậy cực cao (POFOD thấp).

#### **Slide 39-41: Self-monitoring Architectures (Kiến trúc tự giám sát)**
*   **Mô hình đa kênh (Multi-channel):**
    *   Sử dụng nhiều kênh (channel) cùng tính toán một việc.
    *   Kết quả của các kênh được so sánh.
    *   Nếu giống nhau -> OK.
    *   Nếu khác nhau -> Giả định là có lỗi -> Ngắt hệ thống hoặc báo động.
*   **Slide 40:** Sơ đồ minh họa: Input -> Chia ra 2 Channel -> Comparator (Bộ so sánh) -> Output.
*   **Yêu cầu:** Phần cứng và phần mềm của các kênh phải **đa dạng (diverse)**. (Ví dụ: Kênh 1 dùng chip Intel code bằng C++, Kênh 2 dùng chip AMD code bằng Python). Nếu dùng giống hệt nhau thì lỗi phần cứng/phần mềm sẽ xảy ra y hệt nhau -> Bộ so sánh không phát hiện được.

---

### **TỔNG KẾT ĐỂ LÀM BÀI THI (Nửa đầu)**

Khi vào phòng thi, nếu gặp câu hỏi liên quan đến nửa đầu này, bạn hãy tra cứu theo logic sau:

1.  **Hỏi về định nghĩa lỗi:** Xem Slide 4-5 (Phân biệt Fault, Error, Failure).
2.  **Hỏi về chọn chỉ số đo lường (Metric):**
    *   Hệ thống 24/7 (Web, ATM): Chọn **Availability**.
    *   Hệ thống an toàn tính mạng, ít dùng (Báo cháy, Phanh): Chọn **POFOD**.
    *   Hệ thống xử lý nhiều giao dịch (Server thanh toán): Chọn **ROCOF**.
    *   Hệ thống chạy tác vụ dài (Xử lý ảnh vệ tinh): Chọn **MTTF**.
3.  **Hỏi về cách tăng độ tin cậy:** Nhớ từ khóa **Redundancy** (Dư thừa) và **Diversity** (Đa dạng).
Chào bạn, chúng ta tiếp tục đi vào **nửa phần còn lại (Slide 41 - 81)**.

Phần này sẽ đi sâu vào kỹ thuật thực tế: Kiến trúc hệ thống, Các nguyên tắc Code để tránh lỗi (rất hay hỏi trong đề thi dạng tự luận hoặc phân tích code) và Cách đo lường.

Dưới đây là giải thích chi tiết để bạn ghi chú vào tài liệu:

---

### **PHẦN 4: CÁC KIẾN TRÚC CHỊU LỖI NÂNG CAO (Slide 41 - 52)**
*(Tiếp nối phần kiến trúc tự giám sát ở phần trước)*

#### **Slide 41-43: Ví dụ thực tế - Hệ thống bay Airbus (Case Study)**
*   **Nội dung:** Airbus dùng kiến trúc chịu lỗi cực đoan cho hệ thống lái (Flight Control System).
*   **Từ khóa quan trọng: Diversity (Sự đa dạng).**
    *   Họ không chỉ dùng 1 máy tính dự phòng, mà dùng **5 máy tính**.
    *   **Phần cứng khác nhau:** Máy chính dùng chip hãng A, máy phụ dùng chip hãng B (để tránh lỗi phần cứng hàng loạt).
    *   **Phần mềm khác nhau:** Đội viết code cho máy chính dùng ngôn ngữ khác đội viết code cho máy phụ.
*   **Mục đích:** Tránh lỗi **"Common Mode Failure"** (Lỗi điểm chung). Nếu tất cả cùng dùng 1 loại chip hoặc 1 ngôn ngữ lập trình, một lỗi trong chip/ngôn ngữ đó sẽ làm chết toàn bộ 5 máy cùng lúc.

#### **Slide 44-48: N-version Programming (Lập trình đa phiên bản)**
*   **Định nghĩa:**
    *   Một phần mềm được viết thành **N phiên bản** (thường là 3) bởi các đội code khác nhau.
    *   Cả 3 phiên bản chạy song song, cùng xử lý 1 input.
    *   **Voting System (Hệ thống bỏ phiếu):** So sánh kết quả. Nếu 2 ông ra A, 1 ông ra B -> Hệ thống chọn A (theo đa số).
*   **Liên hệ Slide 45-46 (Triple Modular Redundancy - TMR):** Đây là khái niệm gốc bên phần cứng. 3 linh kiện giống hệt nhau chạy song song. Hư 1 cái thì 2 cái kia vẫn chạy ("bầu bán" để loại cái hư ra).
*   **Điểm yếu (Slide 48):** Con người thường tư duy giống nhau. Các đội code khác nhau thường mắc cùng một sai lầm ở những đoạn thuật toán khó. -> Dẫn đến cả 3 phiên bản đều sai -> Hệ thống bỏ phiếu thất bại.

#### **Slide 49-52: Vấn đề của sự đa dạng (Design Diversity)**
*   **Vấn đề lớn nhất (Slide 51): Specification Dependency.**
    *   Tất cả các đội code đều nhìn vào 1 bản Đặc tả (Spec) ban đầu.
    *   Nếu bản Spec viết sai hoặc gây hiểu nhầm -> Cả 3 đội đều code sai theo cùng 1 hướng.
*   **Thực tế (Slide 52):** Kỹ thuật này rất đắt tiền (tốn tiền thuê 3 đội làm 1 việc) nhưng độ tin cậy chỉ tăng khoảng 5-9 lần chứ không phải tuyệt đối. Thường chỉ dùng cho tàu vũ trụ, hạt nhân, tàu hỏa.

---

### **PHẦN 5: LẬP TRÌNH ĐỂ ĐẠT ĐỘ TIN CẬY (Slide 53 - 69)**
*(Phần này cực kỳ quan trọng nếu đề thi yêu cầu: "Nêu các nguyên tắc lập trình an toàn" hoặc cho một đoạn code và hỏi "Vi phạm nguyên tắc nào?")*

**Slide 55:** Tóm tắt 8 nguyên tắc vàng. Hãy đánh dấu kỹ slide này.

#### **1. Limit visibility (Slide 56): Giới hạn tầm nhìn**
*   **Ý nghĩa:** Dùng tính đóng gói (Encapsulation) trong OOP. Dữ liệu nên để `private`.
*   **Tại sao:** Để các thành phần khác không lỡ tay sửa bậy vào dữ liệu quan trọng.

#### **2. Check all inputs (Slide 57-58): Kiểm tra đầu vào**
*   **Nguyên tắc:** Đừng bao giờ tin user.
*   **Các loại check (Slide 58 - Hay thi):**
    *   *Range check:* Tuổi phải từ 0-120.
    *   *Size check:* Tên không quá 40 ký tự (tránh tràn bộ đệm).
    *   *Representation check:* Số điện thoại không được chứa chữ cái.

#### **3. Exception handling (Slide 59-61): Xử lý ngoại lệ**
*   **Ý nghĩa:** Dùng `try-catch`. Khi có lỗi (chia cho 0, mất mạng), chương trình không được Crash (văng ra ngoài) mà phải bắt được lỗi đó và xử lý nhẹ nhàng.
*   **Sơ đồ Slide 60:** Code đang chạy -> Gặp lỗi -> Nhảy vào Exception Handler -> Xử lý -> Thoát hoặc chạy tiếp.

#### **4. Minimize error-prone constructs (Slide 62-65): Tránh dùng lệnh dễ gây lỗi**
*   Các thứ nên tránh (dù ngôn ngữ cho phép):
    *   **Pointers (Con trỏ):** Dễ trỏ sai vùng nhớ gây crash hệ thống (C/C++ hay bị).
    *   **Dynamic memory (Cấp phát động):** Quên giải phóng gây rò rỉ bộ nhớ (Memory Leak).
    *   **Floating-point (Số thực):** So sánh `if (a == b)` với số thực rất nguy hiểm vì độ chính xác không tuyệt đối (0.99999 != 1.0).
    *   **Recursion (Đệ quy):** Dễ gây tràn ngăn xếp (Stack overflow).

#### **5. Restart capabilities (Slide 66): Khả năng khởi động lại**
*   **Ý nghĩa:** Nếu hệ thống chết, phải cho phép khởi động lại nhanh và không mất dữ liệu cũ. (Ví dụ: Word tự save bản nháp, khi mở lại hỏi có muốn khôi phục không).

#### **6. Check array bounds (Slide 67): Kiểm tra biên mảng**
*   **Lỗi kinh điển:** Mảng có 10 phần tử nhưng ghi vào phần tử thứ 11 -> **Buffer Overflow**. Đây là lỗ hổng bảo mật phổ biến nhất để hacker tấn công.
*   **Lời khuyên:** Luôn kiểm tra chỉ số `i` có nằm trong `0..n` không.

#### **7. Timeouts (Slide 68): Dùng thời gian chờ**
*   **Tình huống:** Gọi một API bên ngoài hoặc kết nối Database.
*   **Rủi ro:** Nếu bên kia treo, hệ thống mình cũng treo theo (đợi mãi mãi).
*   **Giải pháp:** Đặt Timeout (ví dụ 5 giây). Sau 5s không trả lời thì tự ngắt và báo lỗi.

#### **8. Name all constants (Slide 69): Đặt tên hằng số**
*   **Bad code:** `Tax = Price * 0.1` (Số 0.1 là magic number, khó hiểu).
*   **Good code:** `Tax_Rate = 0.1; Tax = Price * Tax_Rate`. Dễ đọc, dễ sửa.

---

### **PHẦN 6: ĐO LƯỜNG ĐỘ TIN CẬY (Slide 70 - 78)**

#### **Slide 71: Dữ liệu cần thu thập**
Để tính các chỉ số ở phần 1 (POFOD, ROCOF), ta cần đếm:
1.  Số lượng lỗi (Failures).
2.  Tổng số giao dịch (Transactions) hoặc thời gian chạy.
3.  Thời gian sửa lỗi (để tính Availability).

#### **Slide 72-73: Reliability Testing (Kiểm thử độ tin cậy)**
*   **Phân biệt với Defect Testing (Kiểm thử tìm lỗi):**
    *   *Defect Testing:* Cố tình nhập dữ liệu quái dị, dữ liệu biên để tìm ra bug và sửa. Mục tiêu: **Tìm càng nhiều bug càng tốt**.
    *   *Reliability Testing (Statistical Testing):* Nhập dữ liệu mô phỏng người dùng thật. Mục tiêu: **Đo xem hệ thống chạy ổn định thế nào** (để ra con số % độ tin cậy).

#### **Slide 76-78: Operational Profiles (Hồ sơ vận hành - Khái niệm quan trọng)**
*   **Định nghĩa:** Một tập hợp các đầu vào (Input) phản ánh đúng thói quen sử dụng thực tế của người dùng.
*   **Ví dụ:** Trong phần mềm ATM:
    *   90% người dùng vào để "Rút tiền".
    *   9% vào để "Xem số dư".
    *   1% vào để "Đổi mã PIN".
    *   -> Khi test Reliability, bạn phải tạo bộ test sao cho 90% số test case là Rút tiền. Nếu bạn test 50% Rút tiền - 50% Đổi PIN thì kết quả đo lường độ tin cậy bị sai (không đúng thực tế).
*   **Khó khăn:** Với hệ thống mới toanh, rất khó biết người dùng sẽ dùng như thế nào để tạo Profile này.

---

### **PHẦN 7: TỔNG KẾT (Slide 79-81)**

*   Các slide này tóm tắt lại toàn bộ chương. Bạn nên đọc lướt qua để nhớ các từ khóa chính.

---

### **CHIẾN THUẬT DÙNG TÀI LIỆU TRONG PHÒNG THI**

Khi thi, nếu gặp câu hỏi, bạn tra cứu tài liệu theo các bước sau:

1.  **Câu hỏi về "Làm sao để code an toàn/tránh lỗi?":**
    *   Mở ngay **Slide 55**. Liệt kê 8 nguyên tắc.
    *   Nếu cần ví dụ hoặc giải thích sâu, lật tiếp các slide **56-69**.

2.  **Câu hỏi về "N-version programming" hoặc "Kiến trúc chịu lỗi":**
    *   Mở **Slide 44** (định nghĩa) và **Slide 50-51** (nhược điểm/tại sao nó không hoàn hảo).
    *   Nhớ từ khóa: *Specification Dependency* (Phụ thuộc vào đặc tả).

3.  **Câu hỏi về "Đo lường/Kiểm thử độ tin cậy":**
    *   Nhớ sự khác nhau giữa kiểm thử thông thường và kiểm thử thống kê (**Slide 73**).
    *   Khái niệm "Operational Profile" (**Slide 76**).

4.  **Câu hỏi bài tập tính toán:**
    *   Lật lại **Slide 20-23** (ở nửa phần đầu) để xem công thức Availability, POFOD.

Chúc bạn ôn thi tốt và đạt điểm cao môn này nhé! Nếu cần giải thích thêm khái niệm nào khó hiểu, cứ hỏi tôi.