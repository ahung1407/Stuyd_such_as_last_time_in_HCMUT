Chào bạn, đây là bản phân tích tổng hợp **toàn bộ 81 slide** theo cấu trúc chi tiết mà bạn yêu cầu. Vì số lượng slide lớn, tôi sẽ nhóm các slide có nội dung liên tiếp nhau vào cùng một mục phân tích để đảm bảo tính liền mạch, nhưng vẫn giữ đầy đủ các tiêu chí: Giảng giải, Ứng dụng, Câu hỏi thi, Lỗi thường gặp.

Đây là "phao thi" chi tiết nhất để bạn mang vào phòng thi.

---

### **PHẦN 1: TỔNG QUAN VỀ ĐỘ TIN CẬY (Slide 1 - 16)**

#### **Slide 1 - 3: Giới thiệu & Tầm quan trọng**
*   **Giải thích chi tiết:**
    *   Giảng viên muốn nhấn mạnh sự khác biệt giữa phần mềm "thông thường" (non-critical) và hệ thống quan trọng (critical systems).
    *   Người dùng có thể chấp nhận lỗi ở phần mềm giải trí, nhưng với hệ thống y tế, hàng không, viễn thông, yêu cầu về độ tin cậy là tối thượng.
*   **Ý nghĩa & Ứng dụng:** Khi nhận dự án, PM (Project Manager) phải xác định ngay hệ thống thuộc loại nào để phân bổ ngân sách cho testing.
*   **Câu hỏi thi:**
    ```text
    1. (Dễ) Loại hệ thống nào sau đây yêu cầu độ tin cậy cao nhất?
       A. Game mobile. B. Phần mềm chỉnh sửa ảnh. C. Hệ thống kiểm soát không lưu.
       -> C.

    2. (Trung bình) Tại sao người dùng chấp nhận lỗi trong non-critical applications?
       -> Vì hậu quả của lỗi thấp và chi phí để làm hoàn hảo quá cao so với giá trị mang lại.
    ```

#### **Slide 4 - 5: Faults, Errors và Failures (CỰC KỲ QUAN TRỌNG)**
*   **Giải thích chi tiết:** Đây là chuỗi nhân quả của một sự cố phần mềm:
    1.  **Human error/Mistake:** Lỗi tư duy của lập trình viên (ví dụ: hiểu sai đề bài).
    2.  **System Fault (Bug):** Dòng code sai sinh ra từ tư duy sai đó (nằm im trong source code).
    3.  **System Error:** Trạng thái sai lệch của hệ thống khi chạy qua dòng code lỗi (ví dụ: biến `temp` nhận giá trị âm trong khi phải dương).
    4.  **System Failure:** Hệ thống sập hoặc đưa ra output sai cho người dùng.
*   **Sơ đồ/Mối quan hệ:** Fault $\rightarrow$ Error $\rightarrow$ Failure. Lưu ý Slide 5: Có Fault chưa chắc có Error (nếu không chạy qua dòng đó); có Error chưa chắc có Failure (nếu hệ thống tự sửa được).
*   **Lỗi hay nhầm lẫn:** Đồng nhất Fault và Failure.
    *   *Cách tránh:* Fault là code (tĩnh), Failure là hành vi (động).
*   **Câu hỏi thi:**
    ```text
    1. (Dễ) Nguyên nhân gốc rễ của System Fault là gì?
       -> Human error/Mistake.

    2. (Khó) Một đoạn code sai nằm trong chương trình nhưng người dùng chưa bao giờ dùng tính năng đó. Hệ thống có Fault hay Failure?
       -> Có Fault, nhưng chưa có Failure.

    3. (Tư duy) Tại sao Error không nhất thiết dẫn đến Failure?
       -> Vì hệ thống có thể có cơ chế phát hiện và sửa lỗi (Error detection and recovery).
    ```

#### **Slide 6 - 8: Quản lý lỗi (Fault Management)**
*   **Giải thích chi tiết:** 3 chiến lược đối phó:
    *   *Avoidance:* Tránh từ đầu (Code kỹ, quy trình tốt).
    *   *Detection:* Tìm và sửa (Testing).
    *   *Tolerance:* Chấp nhận sống chung (Hệ thống vẫn chạy dù có lỗi).
    *   Slide 8 (Đồ thị): Chi phí để loại bỏ những lỗi cuối cùng tăng theo hàm mũ. Không thể loại bỏ 100% lỗi.
*   **Ý nghĩa:** Trong dự án thực tế, đến một lúc nào đó phải ngừng fix bug và release sản phẩm vì chi phí fix tiếp quá cao (Diminishing returns).
*   **Câu hỏi thi:**
    ```text
    1. (Trung bình) Biện pháp nào sau đây thuộc về Fault Tolerance?
       A. Review code. B. Unit Test. C. Có server dự phòng tự kích hoạt khi server chính sập.
       -> C.
    ```

#### **Slide 9 - 14: Availability vs Reliability (Định nghĩa & Cảm nhận)**
*   **Giải thích chi tiết:**
    *   **Reliability:** Xác suất chạy KHÔNG LỖI trong một khoảng thời gian ($P(\text{no failure})$).
    *   **Availability:** Xác suất hệ thống SẴN SÀNG dùng tại thời điểm $t$ ($P(\text{available})$).
    *   Slide 14: Cảm nhận của người dùng phụ thuộc vào *môi trường* và *hậu quả*. Lỗi mất điện 5 phút lúc 3h sáng (ít người dùng) nhẹ hơn mất điện 5 phút lúc 19h tối (giờ cao điểm).
*   **Công thức/Mnemonics:**
    *   Reliability $\approx$ "Chạy bền".
    *   Availability $\approx$ "Gọi là có mặt".
*   **Lỗi hay nhầm lẫn:** Nghĩ rằng Reliability cao thì Availability cao.
    *   *Phản ví dụ:* Hệ thống ít lỗi (Reliability cao) nhưng mỗi lần lỗi phải sửa mất 1 tháng $\rightarrow$ Availability thấp.
*   **Câu hỏi thi:**
    ```text
    1. (Khó) Một hệ thống bị crash mỗi giờ một lần (Reliability thấp), nhưng tự khởi động lại trong 0.1 giây. Đánh giá Availability?
       -> Availability rất cao (vì thời gian downtime không đáng kể).
    ```

#### **Slide 15 - 16: Input/Output & Thói quen sử dụng**
*   **Giải thích:** Slide 16 nêu nghịch lý: Sửa x% lỗi bug không làm tăng x% độ tin cậy. Vì nếu sửa bug ở chỗ người dùng không bao giờ dùng thì vô nghĩa.
*   **Ý nghĩa:** Phải tập trung test và fix bug ở những tính năng được dùng nhiều nhất (Operational Profile).

---

### **PHẦN 2: YÊU CẦU ĐỘ TIN CẬY & METRICS (Slide 17 - 32)**

#### **Slide 17 - 19: Phân loại yêu cầu**
*   **Giải thích:**
    *   *Functional reliability req:* Yêu cầu chức năng (Hệ thống phải làm gì? check input, sao lưu...).
    *   *Non-functional reliability req:* Yêu cầu phi chức năng (Các con số POFOD, ROCOF...).

#### **Slide 20: POFOD (Probability of Failure on Demand)**
*   **Giải thích:** Xác suất lỗi khi có 1 yêu cầu.
*   **Công thức:** $POFOD = \frac{\text{Số lần thất bại}}{\text{Tổng số lần yêu cầu}}$.
*   **Ứng dụng:** Hệ thống an toàn (Safety-critical), ít dùng nhưng dùng là phải đúng (Báo cháy, Phanh xe).
*   **Câu hỏi thi:**
    ```text
    1. (Trung bình) Hệ thống túi khí xe hơi nên dùng chỉ số nào?
       -> POFOD (Vì nó nằm chờ, khi có va chạm (demand) mới bung).
    ```

#### **Slide 21: ROCOF và MTTF**
*   **Giải thích:**
    *   *ROCOF (Rate of Occurrence of Failures):* Tần suất lỗi theo thời gian/số lượng giao dịch. Dùng cho hệ thống giao dịch liên tục (Ngân hàng, Đặt vé).
    *   *MTTF (Mean Time To Failure):* Thời gian trung bình giữa các lỗi. Dùng cho hệ thống chạy dài (CAD, Xử lý ảnh).
*   **Công thức:** $MTTF \approx \frac{1}{ROCOF}$.

#### **Slide 22 - 23: Availability (Bảng tra cứu quan trọng)**
*   **Giải thích:** Tỷ lệ thời gian hệ thống hoạt động.
*   **Bảng tra cứu (Slide 23):**
    *   0.9 (90%) $\rightarrow$ Chết 144 phút/ngày.
    *   0.99 $\rightarrow$ Chết 14.4 phút/ngày.
    *   0.999 $\rightarrow$ Chết 84 giây/ngày.
    *   0.9999 $\rightarrow$ Chết 8.4 giây/ngày.
*   **Câu hỏi thi:**
    ```text
    1. (Tính toán) Hệ thống yêu cầu Availability 0.999. Thời gian downtime cho phép trong 24h là bao nhiêu?
       -> 84 giây (Tra bảng hoặc tính: 24h * 60 * 60 * 0.001).
    ```

#### **Slide 27 - 30: Case Studies (ATM & Insulin Pump)**
*   **Phân tích:**
    *   *ATM:* Cần Availability cao (để khách rút tiền). Database quan trọng hơn máy ATM lẻ.
    *   *Insulin Pump:* Cần POFOD thấp (để không tiêm sai thuốc chết người). Phân biệt lỗi tạm thời (Transient - POFOD 0.002) và lỗi vĩnh viễn (Permanent - POFOD 0.00002).

#### **Slide 31 - 32: Ví dụ Functional Requirements**
*   **Giải thích:** 4 loại yêu cầu chức năng để đạt độ tin cậy:
    1.  Checking (Kiểm tra input).
    2.  Recovery (Phục hồi).
    3.  Redundancy (Dư thừa).
    4.  Process (Quy trình phát triển).

---

### **PHẦN 3: KIẾN TRÚC CHỊU LỖI (Slide 33 - 52)**

#### **Slide 33 - 35: Nguyên lý Fault Tolerance**
*   **Từ khóa:** **Redundancy** (Dư thừa - Nhiều cái) và **Diversity** (Đa dạng - Khác nhau).
*   **Lý do:** Nếu dùng 2 máy giống hệt nhau (Redundancy mà không Diversity), lỗi phần mềm sẽ khiến cả 2 chết cùng lúc (Common mode failure).

#### **Slide 36 - 38: Protection Systems (Hệ thống bảo vệ)**
*   **Giải thích:** Một hệ thống độc lập giám sát hệ thống chính.
*   **Đặc điểm:** Phải đơn giản, dùng công nghệ khác biệt (Diverse).
*   **Câu hỏi thi:**
    ```text
    1. (Trung bình) Tại sao hệ thống bảo vệ nên đơn giản?
       -> Để dễ kiểm thử và chứng minh độ tin cậy (Slide 38).
    ```

#### **Slide 39 - 43: Self-monitoring / Airbus**
*   **Giải thích:** Kiến trúc đa kênh (Multi-channel).
*   **Sơ đồ (Slide 40):** Input $\rightarrow$ Channel 1 & 2 $\rightarrow$ Comparator (So sánh). Nếu khác nhau $\rightarrow$ Báo lỗi.
*   **Case study Airbus (Slide 43):**
    *   Dùng 5 máy tính.
    *   Phần cứng: Chip khác hãng.
    *   Phần mềm: Ngôn ngữ khác nhau, đội code khác nhau.
    *   Mục đích: Loại bỏ lỗi điểm chung.

#### **Slide 44 - 48: N-version Programming**
*   **Giải thích:** 3 phiên bản phần mềm chạy song song + Cơ chế bỏ phiếu (Voting).
*   **Vấn đề (Slide 48):** Con người tư duy giống nhau $\rightarrow$ Dễ mắc cùng một lỗi thuật toán dù code độc lập.

#### **Slide 51: Specification Dependency (Tử huyệt)**
*   **Giải thích:** Tất cả các phiên bản đều code dựa trên **cùng một bản đặc tả (Specification)**. Nếu đặc tả sai $\rightarrow$ Tất cả đều sai $\rightarrow$ Hệ thống chịu lỗi vô dụng.
*   **Câu hỏi thi:**
    ```text
    1. (Khó) Hạn chế lớn nhất của N-version programming là gì?
       -> Phụ thuộc vào tính đúng đắn của đặc tả (Specification dependency).
    ```

---

### **PHẦN 4: LẬP TRÌNH ĐỂ ĐẠT ĐỘ TIN CẬY (Slide 53 - 69)**
*(Phần này thường ra câu hỏi thực hành code)*

#### **Slide 55: 8 Nguyên tắc vàng (Học thuộc lòng)**
*   **Mnemonic:** L-C-E-M-R-C-T-N (Limit, Check, Exception, Minimize, Restart, Check array, Timeout, Name).

#### **Phân tích từng nguyên tắc (Slide 56 - 69):**
1.  **Limit visibility (Slide 56):** Che giấu dữ liệu (Encapsulation/Private). Tránh bị sửa bậy.
2.  **Check inputs (Slide 57-58):** Luôn kiểm tra tính hợp lệ (Range, Size, Representation).
3.  **Exception handling (Slide 59-61):** Dùng Try-Catch thay vì để crash.
4.  **Minimize error-prone constructs (Slide 62-65):**
    *   *Tránh:* Pointers (Con trỏ), Dynamic memory (Cấp phát động), Floating-point (Số thực so sánh), Recursion (Đệ quy).
    *   *Tại sao:* Số thực không chính xác; Đệ quy dễ tràn stack; Con trỏ dễ trỏ bậy.
5.  **Restart capabilities (Slide 66):** Cho phép reset lại trạng thái an toàn.
6.  **Check array bounds (Slide 67):** Tránh lỗi Buffer Overflow (tràn bộ đệm) - nguyên nhân hàng đầu của lỗ hổng bảo mật.
7.  **Timeouts (Slide 68):** Tránh treo hệ thống khi gọi dịch vụ ngoài (Distributed systems).
8.  **Name constants (Slide 69):** Dùng tên (`TAX_RATE`) thay vì số (`0.1`) để tránh nhầm lẫn và dễ bảo trì.

*   **Câu hỏi thi:**
    ```text
    1. (Dễ) Tại sao nên dùng hằng số có tên thay vì số trực tiếp?
       -> Để dễ đọc và dễ thay đổi đồng loạt (Maintainability -> Reliability).

    2. (Code) Đoạn code `if (float_A == float_B)` vi phạm nguyên tắc nào?
       -> Minimize error-prone constructs (Floating-point comparison).

    3. (Bảo mật) Lỗi nào xảy ra nếu không kiểm tra biên mảng?
       -> Buffer overflow.
    ```

---

### **PHẦN 5: ĐO LƯỜNG ĐỘ TIN CẬY (Slide 70 - 81)**

#### **Slide 72 - 73: Reliability Testing vs Defect Testing**
*   **Giải thích:**
    *   *Defect Testing:* Tìm lỗi (dùng dữ liệu dị).
    *   *Reliability Testing (Statistical):* Đo độ ổn định (dùng dữ liệu thực tế).
*   **Lỗi hay nhầm lẫn:** Dùng kết quả test tìm lỗi để báo cáo độ tin cậy $\rightarrow$ Sai, vì số liệu không phản ánh thực tế.

#### **Slide 76 - 78: Operational Profiles (Hồ sơ vận hành)**
*   **Giải thích:** Tập hợp dữ liệu test mô phỏng đúng tần suất sử dụng của người dùng thật.
*   **Thách thức (Slide 78):** Khó tạo tự động cho hệ thống tương tác (Interactive systems); Khó biết trước với hệ thống mới.
*   **Câu hỏi thi:**
    ```text
    1. (Tư duy) Tại sao Operational Profile lại quan trọng trong đo lường Reliability?
       -> Vì Reliability phụ thuộc vào cách sử dụng. Lỗi ở tính năng hay dùng sẽ làm giảm Reliability nghiêm trọng hơn lỗi ở tính năng ít dùng.
    ```

#### **Slide 79 - 81: Key Points (Tổng kết)**
*   Slide 81 chốt lại: Statistical testing dựa trên Operational Profile là cách duy nhất để ước lượng Reliability một cách khoa học.

---

### **LỜI KHUYÊN KHI TRA CỨU TRONG PHÒNG THI**

1.  **Nếu đề hỏi về Code:** Lật ngay **Slide 55** và các slide sau đó.
2.  **Nếu đề hỏi về Tính toán (99.9%):** Lật ngay **Slide 23**.
3.  **Nếu đề hỏi về các chỉ số (POFOD, ROCOF):** Lật **Slide 20-21**.
4.  **Nếu đề hỏi về Kiến trúc (Airbus, N-version):** Lật **Slide 40-50**.

Chúc bạn làm bài thi xuất sắc!