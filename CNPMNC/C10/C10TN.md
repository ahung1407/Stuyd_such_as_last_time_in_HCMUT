Tuyệt vời! Dưới đây là 10 câu hỏi trắc nghiệm dạng tư duy và hiểu, được thiết kế để bạn áp dụng kiến thức từ các slide (đã được bạn mang vào phòng thi) chứ không chỉ đơn thuần là nhớ định nghĩa.

---

### **Các Câu Hỏi Trắc Nghiệm Dạng Hiểu và Tư Duy**

**1. Trong mô hình chồng các hệ thống kinh tế-xã hội (STS stack), một sự thay đổi trong "Laws, regulation and culture" (Society) có khả năng gây ảnh hưởng trực tiếp và lan truyền đến lớp nào nhất trước khi chạm đến Application system?**
A. Organization
B. Business processes
C. Communications and data management
D. Operating system
Đáp án: B
Giải thích: A sai vì Organization là lớp cao, ảnh hưởng có thể gián tiếp hơn; B đúng vì Luật pháp (Society) trực tiếp quy định cách thức hoạt động (Business processes), và sau đó Quy trình kinh doanh mới yêu cầu thay đổi trong hệ thống ứng dụng; C sai vì đây là lớp kỹ thuật thấp hơn, thường không bị ảnh hưởng trực tiếp bởi luật pháp; D sai vì đây là lớp kỹ thuật rất thấp, không liên quan trực tiếp đến quy định xã hội

**2. Nếu một hệ thống thương mại điện tử bị tấn công từ chối dịch vụ (Denial of Service - DoS), thuộc tính độ tin cậy nào bị ảnh hưởng trực tiếp nhất, và thuộc tính nào trong 5 thuộc tính chính (Slide 7) được thiết kế để đối phó với loại sự kiện này?**
A. Bị ảnh hưởng: Reliability; Đối phó: Safety
B. Bị ảnh hưởng: Availability; Đối phó: Resilience
C. Bị ảnh hưởng: Security; Đối phó: Availability
D. Bị ảnh hưởng: Resilience; Đối phó: Reliability
Đáp án: B
Giải thích: A sai vì DoS tấn công khả năng truy cập (Availability), không phải tính đúng đắn của kết quả (Reliability); B đúng vì DoS cố gắng làm hệ thống không khả dụng (Unavailable), và Resilience là khả năng chống chịu và phục hồi sau sự kiện gây rối như tấn công mạng; C sai vì Security là ngăn chặn, nhưng hậu quả trực tiếp là Availability bị giảm; D sai vì Resilience là khả năng đối phó, không phải bị ảnh hưởng trực tiếp nhất, và Reliability không phải là thuộc tính đối phó chính với tấn công DoS

**3. Tại sao "Operational failure" (lỗi do con người) được coi là nguyên nhân đơn lẻ lớn nhất gây ra hỏng hóc hệ thống trong các hệ thống kinh tế-xã hội (Slide 5)?**
A. Phần cứng và phần mềm hiện đại đã hoàn toàn loại bỏ lỗi.
B. Lỗi phần mềm đã được loại bỏ gần như hoàn toàn nhờ Formal methods.
C. Các hệ thống hiện nay rất phức tạp, đòi hỏi sự tương tác phức tạp của con người, dẫn đến khả năng mắc lỗi vận hành cao hơn.
D. Con người luôn cố tình tạo ra lỗi trong hệ thống.
Đáp án: C
Giải thích: A sai vì phần cứng và phần mềm vẫn có lỗi; B sai vì Formal methods có phạm vi áp dụng hạn chế (Slide 45); C đúng vì khi hệ thống càng phức tạp (Sociotechnical systems), lỗi do tương tác phức tạp giữa con người và máy móc càng trở nên phổ biến và nghiêm trọng hơn; D sai vì lỗi vận hành chủ yếu là ngẫu nhiên, không cố ý (Slide 5)

**4. Khái niệm "Redundant and diverse components should be independent so that they will not suffer from 'common-mode' failures" (Slide 27) nhấn mạnh điều gì?**
A. Dư thừa luôn tốt hơn đa dạng.
B. Sự đa dạng về phần cứng là đủ để đảm bảo độ tin cậy.
C. Mục tiêu là đảm bảo nếu một lỗi thiết kế/lập trình xảy ra, nó sẽ không làm hỏng tất cả các phiên bản cùng một lúc.
D. Tất cả các thành phần dư thừa phải chạy trên cùng một hệ điều hành.
Đáp án: C
Giải thích: A sai vì cả hai đều quan trọng; B sai vì đa dạng có thể áp dụng cho nhiều khía cạnh (phần mềm, quy trình, hệ điều hành); C đúng vì lỗi chế độ chung (common-mode failure) là lỗi ảnh hưởng đến tất cả các thành phần đa dạng/dư thừa (ví dụ: lỗi thiết kế chung), và mục tiêu của việc độc lập là tránh điều này; D sai vì việc chạy trên cùng HĐH tăng nguy cơ common-mode failure (ví dụ: lỗ hổng bảo mật của HĐH)

**5. Theo slide về "Dependability costs" (Slide 14), sự gia tăng chi phí theo cấp số nhân khi đòi hỏi mức độ tin cậy cao hơn chủ yếu đến từ đâu?**
A. Chỉ từ việc mua phần cứng đắt tiền hơn.
B. Chỉ từ việc thuê thêm nhân viên.
C. Từ việc sử dụng các kỹ thuật phát triển đắt tiền hơn VÀ tăng cường kiểm thử/xác nhận để được cấp phép/chứng nhận.
D. Từ việc người dùng yêu cầu nhiều tính năng hơn.
Đáp án: C
Giải thích: A sai vì chỉ là một phần nhỏ; B sai vì không phải nguyên nhân chính; C đúng vì slide 14 nêu rõ hai lý do: (1) sử dụng kỹ thuật và phần cứng đắt tiền, và (2) tăng cường kiểm thử và xác nhận để thuyết phục cơ quan quản lý (regulation); D sai vì đây là về tính năng, không phải về độ tin cậy

**6. Một công ty đang phát triển một hệ thống điều khiển tàu hỏa (Regulated system). Họ sử dụng phương pháp phát triển Agile truyền thống (co-development, minimizing documentation). Theo nội dung chương 10 (Slide 37, 38), vấn đề lớn nhất họ sẽ gặp phải là gì?**
A. Hệ thống sẽ không thể chạy được trên phần cứng.
B. Thiếu "Tài liệu quy trình và sản phẩm" và "Phân tích yêu cầu từ đầu" sẽ cản trở việc đạt được chứng nhận (certification) an toàn/độ tin cậy.
C. Các kỹ sư Agile không thể làm việc trên hệ thống quan trọng.
D. Họ sẽ phải sử dụng ngôn ngữ lập trình C++.
Đáp án: B
Giải thích: A sai vì không phải là xung đột chính; B đúng vì phần mềm đáng tin cậy cần chứng nhận, yêu cầu tài liệu quy trình/sản phẩm và phân tích yêu cầu từ đầu, điều này xung đột với nguyên tắc Agile (tối thiểu hóa tài liệu); C sai vì không phải là vấn đề chung; D sai vì ngôn ngữ lập trình không phải là xung đột chính

**7. "Developing a formal specification requires the system requirements to be analyzed in detail. This helps to detect problems, inconsistencies and incompleteness in the requirements" (Slide 44). Đây là lợi ích chính của phương pháp hình thức, nhưng nó tương ứng với giai đoạn nào trong việc đạt được độ tin cậy (Slide 12)?**
A. Thiết kế V&V processes để khám phá residual errors.
B. Tránh đưa vào accidental errors khi phát triển hệ thống.
C. Thiết kế hệ thống fault tolerant.
D. Thiết kế protection mechanisms.
Đáp án: B
Giải thích: A liên quan đến lỗi đã tồn tại (residual errors), trong khi phân tích yêu cầu bằng FM là **phòng ngừa** (giúp phát hiện lỗi yêu cầu trước khi code) – đây là hoạt động tránh đưa lỗi vào; B đúng vì phát hiện vấn đề yêu cầu/thiết kế sớm là một hình thức tránh lỗi ngẫu nhiên (accidental errors); C và D là các cơ chế chịu lỗi và bảo vệ, không liên quan trực tiếp đến việc phân tích yêu cầu

**8. Thuộc tính "Maintainability" (Khả năng bảo trì) được định nghĩa là "Reflects the extent to which the system can be adapted to new requirements" (Slide 10). Nếu một hệ thống có Maintainability thấp, điều này sẽ ảnh hưởng tiêu cực đến thuộc tính chính nào nhất của hệ thống đó theo thời gian?**
A. Reliability
B. Safety
C. Security
D. Cả Reliability, Safety và Security đều có thể bị ảnh hưởng.
Đáp án: D
Giải thích: A sai vì nó ảnh hưởng đến nhiều hơn Reliability; B sai vì nó ảnh hưởng đến nhiều hơn Safety; C sai vì nó ảnh hưởng đến nhiều hơn Security; D đúng vì khi một hệ thống không thể bảo trì dễ dàng (Maintainability thấp), việc vá lỗi (Reliability), cập nhật quy tắc an toàn (Safety) hoặc áp dụng bản sửa lỗi bảo mật (Security) sẽ trở nên khó khăn, tốn kém và dễ gây ra lỗi mới, từ đó làm suy giảm tất cả các thuộc tính chính theo thời gian

**9. Hệ thống đáng tin cậy yêu cầu một quy trình "Repeatable" (Lặp lại được) (Slide 33). Điều gì sau đây là lợi ích chính của việc có một quy trình phát triển phần mềm lặp lại được?**
A. Giảm chi phí phần cứng xuống mức thấp nhất.
B. Cho phép quy trình được lặp lại trên các dự án khác nhau và với các thành viên nhóm khác nhau mà không dựa vào diễn giải cá nhân.
C. Tăng cường tốc độ viết mã lên gấp đôi.
D. Loại bỏ hoàn toàn nhu cầu về kiểm thử.
Đáp án: B
Giải thích: A sai vì không liên quan; B đúng vì đây chính là định nghĩa và mục đích cốt lõi của quy trình lặp lại được, không phụ thuộc vào kỹ năng và phán đoán cá nhân, đảm bảo tính nhất quán của sản phẩm; C sai vì mục tiêu là chất lượng và độ tin cậy, không phải tốc độ viết code; D sai vì kiểm thử vẫn luôn cần thiết

**10. Mục tiêu của việc sử dụng các thành phần "diverse" (đa dạng) trong thiết kế hệ thống đáng tin cậy (Slide 27) là gì?**
A. Đảm bảo rằng hệ thống chỉ hoạt động được trên một nền tảng duy nhất.
B. Tăng cường khả năng chịu lỗi bằng cách đảm bảo rằng nếu một thành phần có lỗi do một nguyên nhân cụ thể (ví dụ: lỗi compiler), thì các thành phần khác sẽ không bị ảnh hưởng bởi cùng nguyên nhân đó.
C. Giảm số lượng thành phần trong hệ thống.
D. Giúp việc lập trình dễ dàng hơn.
Đáp án: B
Giải thích: A sai vì đa dạng hướng đến việc sử dụng nhiều nền tảng khác nhau; B đúng vì đa dạng giúp tránh "lỗi chế độ chung" (common-mode failures), nơi một lỗi duy nhất (như lỗi compiler hoặc lỗi thiết kế) có thể làm hỏng tất cả các phiên bản; C sai vì đa dạng thường tăng số lượng thành phần; D sai vì đa dạng thường làm tăng độ phức tạp (Slide 30)