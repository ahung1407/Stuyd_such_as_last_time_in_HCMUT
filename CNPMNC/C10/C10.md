Tuyệt vời. Đây là phần phân tích chi tiết từng slide theo cấu trúc yêu cầu, được thiết kế để bạn làm chủ toàn bộ nội dung của Chương 10 và sẵn sàng cho kỳ thi mang tài liệu.

---

### **Phần 1: Khái niệm và Mục tiêu**

#### **Slide 2: Topics covered**

Giải thích chi tiết (dùng lời của giảng viên):
Thưa các bạn, Slide 2 này chính là **bản đồ tư duy** của toàn bộ chương. Nó cho thấy chúng ta sẽ đi từ **khái niệm cơ bản** (1. Dependability properties), đến **bối cảnh rộng hơn** của hệ thống (2. Sociotechnical systems), và sau đó là các **kỹ thuật cốt lõi** để đạt được độ tin cậy (3. Redundancy & Diversity, 4. Dependable processes, 5. Formal methods). Hãy nhớ thứ tự này, vì nó phản ánh quy trình suy nghĩ logic khi xây dựng một hệ thống đáng tin cậy.

Ý nghĩa & ứng dụng thực tế:
*   Cung cấp cấu trúc rõ ràng cho việc phát triển và kiểm tra hệ thống.
*   Giúp phân loại các hoạt động kỹ thuật (ví dụ: Formal Methods là kỹ thuật tránh lỗi, Redundancy là kỹ thuật chịu lỗi).
*   Đảm bảo không bỏ sót khía cạnh nào trong thiết kế hệ thống quan trọng.

Gợi ý câu hỏi thi:
*   **Dễ:** Kể tên ba chủ đề cốt lõi liên quan đến kỹ thuật đạt được độ tin cậy được trình bày trong chương. (Đáp án: Redundancy & diversity, Dependable processes, Formal methods.)
*   **Trung bình:** Chủ đề nào trong 5 chủ đề bao gồm yếu tố con người, xã hội và tổ chức trong việc phát triển hệ thống? (Đáp án: Sociotechnical systems.)
*   **Khó:** Giải thích mối liên hệ giữa "Quy trình đáng tin cậy" và "Phương pháp hình thức" trong việc đạt được mục tiêu "Tránh đưa vào lỗi ngẫu nhiên" (accidental errors). (Đáp án: Dependable processes thiết lập V&V, còn Formal Methods là kỹ thuật được sử dụng trong các process đó để *tránh* lỗi trong đặc tả/thiết kế.)

Những lỗi hay nhầm lẫn thường gặp & cách tránh:
*   **Lỗi:** Coi Sociotechnical systems là một kỹ thuật thay vì một bối cảnh.
*   **Cách tránh:** Nhớ Sociotechnical systems là **Context**, còn R&D, Process, FM là **Techniques**.

#### **Slide 3: System dependability**

Giải thích chi tiết (dùng lời của giảng viên):
Đây là định nghĩa cốt lõi. Thuật ngữ **Dependability** (Độ tin cậy) là một **thuộc tính hệ thống (system property)** bao trùm. Nó không chỉ là việc hệ thống không hỏng, mà quan trọng hơn, là **mức độ tin cậy (trust)** của người dùng vào hệ thống đó. Nếu người dùng không tin, hệ thống coi như thất bại, bất kể code có hoàn hảo đến đâu. Slide này còn nêu ra 3 thuộc tính cơ bản cấu thành Dependability là: **Reliability** (Độ tin cậy), **Availability** (Khả dụng), và **Security** (An ninh). Lưu ý, các thuộc tính này **phụ thuộc lẫn nhau (inter-dependent)** – một lỗ hổng bảo mật (Security) có thể làm hỏng dữ liệu, dẫn đến hệ thống đưa ra kết quả sai (giảm Reliability).

Ý nghĩa & ứng dụng thực tế:
*   **Mục tiêu chính:** Dependability là mục tiêu tổng thể, là lý do chúng ta làm phần mềm an toàn.
*   **Lợi thế cạnh tranh:** Hệ thống đáng tin cậy tạo dựng được lòng tin khách hàng.
*   **Cơ sở cho Safety Case:** Đây là điểm khởi đầu khi xây dựng hồ sơ chứng minh độ tin cậy.

Gợi ý câu hỏi thi:
*   **Dễ:** Thuật ngữ cốt lõi mà Dependability phản ánh đối với người dùng là gì? (Đáp án: Trust.)
*   **Trung bình:** Giải thích sự khác biệt giữa "Dependability" và "Reliability" dựa trên định nghĩa trong slide. (Đáp án: Dependability là thuộc tính bao trùm (trust), Reliability là một thuộc tính con (khả năng cung cấp dịch vụ đúng như mong đợi).)
*   **Khó:** Trình bày một kịch bản đơn giản minh họa tính phụ thuộc lẫn nhau của Reliability, Availability, và Security. (Đáp án: Một cuộc tấn công DoS (tấn công Security) làm hệ thống quá tải, gây mất dịch vụ (giảm Availability).)

Những lỗi hay nhầm lẫn thường gặp & cách tránh:
*   **Lỗi:** Đồng nhất Dependability với Reliability.
*   **Cách tránh:** Nhớ: $Dependability = \{Reliability, Availability, Security, Safety, Resilience, ...\}$

#### **Slide 4: Importance of dependability**

Giải thích chi tiết (dùng lời của giảng viên):
Slide này trả lời câu hỏi "Tại sao chúng ta phải quan tâm?" Nó nhấn mạnh **hậu quả (effects)** của việc thiếu độ tin cậy. Khi hệ thống không đáng tin cậy, chi phí không chỉ là tiền sửa chữa code. Nó bao gồm: 1) **Tác động lan rộng** (ví dụ: mất điện cả thành phố). 2) **Từ chối người dùng** (hệ thống không an toàn/tin cậy bị tẩy chay). 3) **Tổn thất kinh tế và vật chất** (ví dụ: nhà máy đóng cửa, tai nạn). 4) **Chi phí phục hồi** sau khi mất dữ liệu.

Ý nghĩa & ứng dụng thực tế:
*   **Tính toán ROI (Return on Investment):** Chi phí phát triển độ tin cậy cao được biện minh bằng cách *tránh* được chi phí hỏng hóc cao.
*   **Quản lý rủi ro:** Đây là cơ sở để đánh giá rủi ro hệ thống.

Gợi ý câu hỏi thi:
*   **Dễ:** Kể tên một hậu quả trực tiếp của việc hệ thống không đáng tin cậy liên quan đến người dùng. (Đáp án: Hệ thống không đáng tin cậy có thể bị người dùng từ chối.)
*   **Trung bình:** Giải thích tại sao một hệ thống không đáng tin cậy có thể gây tổn thất kinh tế MÀ KHÔNG CẦN gây thiệt hại vật chất. (Đáp án: Gây mất mát thông tin quan trọng hoặc làm gián đoạn quy trình kinh doanh, dẫn đến chi phí phục hồi cao.)
*   **Khó:** Phân tích một hệ thống không an toàn (unsafe) khác biệt như thế nào với một hệ thống không đáng tin cậy (unreliable) về mặt hậu quả, dựa trên slide này. (Đáp án: Unsafe gây thiệt hại vật chất/con người; Unreliable gây ra kết quả sai hoặc bị từ chối, nhưng cả hai đều là các dạng hỏng hóc gây tổn thất.)

#### **Slide 5: Causes of failure**

Giải thích chi tiết (dùng lời của giảng viên):
Các bạn phải ghi nhớ 3 nguyên nhân cốt lõi gây ra hỏng hóc hệ thống. Điều quan trọng nhất là điểm cuối cùng: **Operational failure (Lỗi vận hành)**. Lỗi này do **con người (human operators)** mắc lỗi. Trong các hệ thống kinh tế-xã hội hiện đại (sociotechnical systems), đây đã trở thành nguyên nhân đơn lẻ lớn nhất.
*   **Hardware failure:** Rõ ràng, lỗi vật lý hoặc hết đời.
*   **Software failure:** Là lỗi thiết kế logic (Specification, Design) hoặc lỗi code (Implementation).
*   **Operational failure:** Ví dụ: người dùng nhập sai lệnh, quản trị viên cấu hình sai, hoặc phản ứng sai với cảnh báo.

Ý nghĩa & ứng dụng thực tế:
*   **Chiến lược phòng ngừa:** Nếu Operational failure là lớn nhất, chúng ta cần đầu tư vào thiết kế giao diện người dùng (UI/UX) tốt hơn, quy trình vận hành rõ ràng, và đào tạo.
*   **Phân tích nguyên nhân gốc:** Khi xảy ra sự cố, đây là 3 hướng điều tra chính.

Gợi ý câu hỏi thi:
*   **Dễ:** Nguyên nhân nào hiện được coi là nguyên nhân đơn lẻ lớn nhất gây ra hỏng hóc trong các hệ thống kinh tế-xã hội? (Đáp án: Operational failure.)
*   **Trung bình:** Nếu phần mềm của một máy thở không đáp ứng được yêu cầu thời gian thực (timing constraints) và gây lỗi, đó là loại hỏng hóc nào? (Đáp án: Software failure (Lỗi thiết kế/implementation).)
*   **Khó:** Phân tích tại sao trong các hệ thống hiện đại, lỗi do con người (Operational failure) lại vượt qua lỗi phần cứng và phần mềm. (Đáp án: Do tính phức tạp gia tăng của hệ thống, con người phải tương tác với nhiều giao diện và đưa ra nhiều quyết định trong các tình huống căng thẳng, làm tăng khả năng mắc lỗi vận hành.)

---

### **Phần 2: Các Thuộc tính Độ tin cậy (Dependability Properties)**

#### **Slide 7: The principal dependability properties (Diagram)**

Giải thích chi tiết (dùng lời của giảng viên):
Slide 7 là **Sơ đồ Dependability Vàng**. Nó mở rộng 3 thuộc tính cơ bản từ Slide 3 và thêm **Safety** (An toàn) và **Resilience** (Khả năng phục hồi).
*   **Availability:** Có sẵn (Up) khi cần.
*   **Reliability:** Làm đúng như đã cam kết (Specified).
*   **Safety:** Không gây hại (No catastrophic failure).
*   **Security:** Chống lại xâm nhập (Intrusion).
*   **Resilience:** Chống chịu và phục hồi (Resist and recover).
Sơ đồ này cực kỳ quan trọng vì nó định nghĩa các mục tiêu thiết kế chi tiết cho mọi hệ thống quan trọng.

Ý nghĩa & ứng dụng thực tế:
*   **Thiết lập Yêu cầu (Requirements):** Các yêu cầu hệ thống quan trọng thường được đặt ra theo các thuộc tính này (ví dụ: Yêu cầu Availability là 99.999%).
*   **Phân tích Lỗ hổng:** Phân tích rủi ro theo từng thuộc tính.

Gợi ý câu hỏi thi:
*   **Dễ:** Khả năng của hệ thống để chống chịu và phục hồi từ các sự kiện gây hại được gọi là gì? (Đáp án: Resilience.)
*   **Trung bình:** Sự khác biệt cốt lõi giữa Reliability và Safety là gì theo định nghĩa sơ đồ này? (Đáp án: Reliability là làm đúng *như đã specified*; Safety là làm đúng *mà không gây ra lỗi thảm khốc*.)
*   **Khó:** Nếu một hệ thống được thiết kế để chịu lỗi thảm khốc nhưng lại đưa ra kết quả sai lệch trong 5% thời gian (dù không thảm khốc), thuộc tính nào bị đánh giá cao (High) và thuộc tính nào bị đánh giá thấp (Low)? (Đáp án: Safety có thể là High; Reliability chắc chắn là Low.)

#### **Slide 8 & 9: Principal properties (Definitions)**

Giải thích chi tiết (dùng lời của giảng viên):
Các slide này đưa ra định nghĩa chi tiết, nhấn mạnh vào các từ khóa:
*   **Availability:** **Probability** (Xác suất) up and running.
*   **Reliability:** **Probability** correctly deliver services.
*   **Safety:** **Judgment** of how likely it is to cause **damage**.
*   **Security:** **Judgment** of how likely it is to **resist intrusions**.
*   **Resilience:** **Judgment** of how well it can maintain **continuity** of critical services in the presence of disruptive events.

Ý nghĩa & ứng dụng thực tế:
*   Cung cấp các số liệu và tiêu chí đo lường cho các thuộc tính.

Gợi ý câu hỏi thi:
*   **Dễ:** Thuộc tính nào liên quan trực tiếp đến "The probability that the system will be up and running..."? (Đáp án: Availability.)
*   **Trung bình:** Giải thích điểm khác biệt chính giữa Security và Resilience dựa trên định nghĩa. (Đáp án: Security là về *chống lại* xâm nhập; Resilience là về *duy trì liên tục* dịch vụ khi có sự kiện gây rối, bao gồm cả tấn công.)
*   **Khó:** Trong một hệ thống y tế, lỗi làm treo máy chủ ảnh hưởng đến **Availability**. Lỗi làm tính sai liều thuốc ảnh hưởng đến **Reliability** và **Safety**. Lỗi nào có thể được đo lường bằng "xác suất" và lỗi nào bằng "đánh giá" (judgment)? (Đáp án: Availability và Reliability đo bằng xác suất; Safety, Security, Resilience đo bằng đánh giá (Judgment) hoặc likelihood.)

#### **Slide 10: Other dependability properties**

Giải thích chi tiết (dùng lời của giảng viên):
3 thuộc tính này bổ sung cho khả năng **bảo trì và vận hành** của hệ thống:
*   **Repairability (Khả năng sửa chữa):** Sau khi hỏng, nó sửa được nhanh đến mức nào. (Liên quan đến việc giảm thời gian downtime, cải thiện Availability).
*   **Maintainability (Khả năng bảo trì):** Khả năng thay đổi, thích nghi với yêu cầu mới (ví dụ: vá lỗ hổng bảo mật, cập nhật luật mới). (Quan trọng cho Security và Reliability dài hạn).
*   **Error tolerance (Khả năng chịu lỗi đầu vào):** Liên quan đến Operational failure (lỗi con người).

Ý nghĩa & ứng dụng thực tế:
*   Là các mục tiêu thiết kế được tối ưu hóa sau khi các thuộc tính chính được đảm bảo.

Gợi ý câu hỏi thi:
*   **Dễ:** Thuộc tính nào phản ánh mức độ hệ thống có thể được thích nghi với các yêu cầu mới? (Đáp án: Maintainability.)
*   **Trung bình:** Khả năng chịu lỗi đầu vào (Error tolerance) là một biện pháp đối phó trực tiếp với loại lỗi nào trong 3 loại lỗi chính (Slide 5)? (Đáp án: Operational failure.)
*   **Khó:** Một hệ thống có Repairability cao và Availability cao có nhất thiết phải có Maintainability cao không? Giải thích. (Đáp án: Không nhất thiết. Repairability/Availability cao có thể đạt được bằng Redundancy (thiết bị dự phòng) mà không cần hệ thống dễ thay đổi code (Maintainability).)

#### **Slide 11: Dependability attribute dependencies**

Giải thích chi tiết (dùng lời của giảng viên):
Slide này giải thích tại sao 5 thuộc tính lại **phụ thuộc lẫn nhau**. Không thể đạt được cái này mà bỏ qua cái kia.
*   **Safety $\leftrightarrow$ Availability/Reliability:** Hệ thống không khả dụng (Unavailable) hoặc không đáng tin cậy (Unreliable) có thể dẫn đến hậu quả không an toàn (Unsafe) (ví dụ: Hệ thống kiểm soát tàu hỏa hỏng (Unavailable) có thể gây tai nạn).
*   **Security $\leftrightarrow$ Reliability/Availability:** Tấn công mạng (Security issue) có thể làm hỏng dữ liệu (giảm Reliability) hoặc gây từ chối dịch vụ (giảm Availability).

Ý nghĩa & ứng dụng thực tế:
*   **Thiết kế cân bằng:** Cần thiết kế đồng thời cho cả 5 thuộc tính. Việc ưu tiên quá mức cho Security có thể làm giảm Usability, dẫn đến Operational failure.

Gợi ý câu hỏi thi:
*   **Dễ:** Lỗ hổng bảo mật dẫn đến dữ liệu bị hỏng sẽ ảnh hưởng đến thuộc tính nào? (Đáp án: Reliability.)
*   **Trung bình:** Nếu bạn bị mất quyền truy cập vào một dịch vụ web do tấn công từ chối dịch vụ (DoS), thuộc tính Dependability nào bị ảnh hưởng chủ yếu? (Đáp án: Availability.)
*   **Khó:** Phân tích: Sự đánh đổi giữa Safety và Availability thường xảy ra như thế nào? (Đáp án: Để đảm bảo Safety, hệ thống thường được thiết kế để tự động tắt (fail-safe) khi phát hiện lỗi, dẫn đến mất dịch vụ (giảm Availability).)

#### **Slide 12 & 13: Dependability achievement**

Giải thích chi tiết (dùng lời của giảng viên):
Đây là **chiến lược 3-phần** để đạt được độ tin cậy:
1.  **Avoidance (Tránh):** Ngăn chặn lỗi xảy ra ngay từ đầu (tránh **accidental errors**). Ví dụ: Formal methods, Reviews.
2.  **Detection/Tolerance (Phát hiện/Chịu lỗi):** Phát hiện lỗi và chịu đựng để hệ thống vẫn chạy (thiết kế **fault tolerant**). Ví dụ: V&V processes, Redundancy.
3.  **Protection/Recovery (Bảo vệ/Phục hồi):** Chống lại tấn công (external attacks) và khôi phục sau sự cố. Ví dụ: Protection mechanisms, Recovery mechanisms.

Ý nghĩa & ứng dụng thực tế:
*   **Khung phát triển:** Khung này xác định các hoạt động trong suốt vòng đời phát triển phần mềm (SDLC).

Gợi ý câu hỏi thi:
*   **Dễ:** Hoạt động nào trong Dependability achievement nhằm mục đích chống lại các cuộc tấn công bên ngoài? (Đáp án: Design protection mechanisms.)
*   **Trung bình:** "Thiết kế hệ thống để chịu lỗi" (fault tolerant) là một phần của chiến lược đạt độ tin cậy nào? (Đáp án: Detection/Tolerance.)
*   **Khó:** Phân tích vai trò của "Design V&V processes" (Slide 12) và "Include recovery mechanisms" (Slide 13) trong mô hình đạt độ tin cậy. (Đáp án: V&V là để *phát hiện* lỗi còn sót lại (Detection); Recovery Mechanisms là để *phục hồi* sau khi lỗi xảy ra.)

#### **Slide 14 & 15: Dependability costs & Curve**

Giải thích chi tiết (dùng lời của giảng viên):
Các bạn cần hiểu rõ **quy luật hàm mũ** ở đây.
$$
\text{Chi phí Dependability} \propto e^{\text{Mức độ Dependability}}
$$
Việc đạt được $99\%$ Reliability dễ hơn rất nhiều so với $99.999\%$. Chi phí tăng vọt vì 2 lý do:
1.  **Kỹ thuật đắt tiền:** Phải dùng Formal Methods, phần cứng Redundant, kỹ sư có kinh nghiệm cao.
2.  **Chứng minh đắt tiền:** **Tăng cường testing và validation** để **thuyết phục** client và regulator (cơ quan quản lý) là tốn kém hơn cả việc code.

Ý nghĩa & ứng dụng thực tế:
*   **Quyết định kinh tế:** Là cơ sở cho việc đặt ra các yêu cầu độ tin cậy thực tế và khả thi về mặt tài chính (Slide 16).

Gợi ý câu hỏi thi:
*   **Dễ:** Chi phí độ tin cậy có xu hướng tăng theo quy luật nào khi yêu cầu mức độ tin cậy cao hơn? (Đáp án: Tăng theo cấp số nhân (exponentially).)
*   **Trung bình:** Lý do nào sau đây liên quan đến việc *chứng minh* độ tin cậy thay vì việc *tạo ra* độ tin cậy? (Đáp án: Increased testing and system validation to convince regulators.)
*   **Khó:** Giải thích tại sao việc chuyển từ mức độ Dependability "High" sang "Very high" lại có sự tăng vọt chi phí lớn hơn so với "Low" sang "Medium", dựa trên hai lý do được liệt kê. (Đáp án: Mức độ cao hơn đòi hỏi phải sử dụng các *kỹ thuật đắt tiền* như FM/N-Version Programming (Lý do 1) và phải qua *quy trình chứng nhận* nghiêm ngặt (Lý do 2), cả hai đều không cần thiết ở mức độ thấp/trung bình.)

#### **Slide 16: Dependability economics**

Giải thích chi tiết (dùng lời của giảng viên):
Đây là **đánh đổi kinh tế**. Vì chi phí tăng quá nhanh, đôi khi việc chấp nhận một mức rủi ro nhất định và **chấp nhận trả chi phí hỏng hóc** lại hiệu quả hơn là cố gắng đạt mức hoàn hảo. Tuy nhiên, điều này phụ thuộc vào:
1.  **Yếu tố xã hội/chính trị:** Không thể áp dụng cho hệ thống an toàn sinh mạng.
2.  **Uy tín (Reputation):** Mất lòng tin khách hàng có thể mất kinh doanh trong tương lai.

Ý nghĩa & ứng dụng thực tế:
*   **Phân loại hệ thống:** Giúp quyết định mức độ đầu tư: *Hệ thống tài chính* (mất tiền) cần Dependability cao; *Hệ thống đăng ký trực tuyến* (mất thời gian) có thể chấp nhận mức độ vừa phải.

Gợi ý câu hỏi thi:
*   **Dễ:** Việc chấp nhận hệ thống untrustworthy và trả chi phí thất bại có thể hiệu quả chi phí hơn trong bối cảnh nào? (Đáp án: Khi chi phí đạt độ tin cậy cao quá lớn, đặc biệt đối với business systems thông thường.)
*   **Trung bình:** Ngoài chi phí trực tiếp, yếu tố nào liên quan đến kinh tế và xã hội có thể buộc công ty phải đầu tư vào Dependability cao? (Đáp án: Uy tín thương hiệu và yếu tố chính trị/xã hội.)
*   **Khó:** Tại sao các hệ thống được quy định (Regulated systems) không thể áp dụng triết lý "chấp nhận rủi ro và trả chi phí hỏng hóc"? (Đáp án: Vì Safety (an toàn sinh mạng) và Security là yêu cầu pháp lý, không phải là thứ có thể đánh đổi bằng tiền.)

---

### **Phần 3: Hệ thống Kinh tế-Xã hội (Sociotechnical Systems - STS)**

#### **Slide 19: The sociotechnical systems stack (Diagram)**

Giải thích chi tiết (dùng lời của giảng viên):
Slide 19 là mô hình **STS Stack** 7 lớp. Nó minh họa rõ ràng: **Software Engineering** chỉ là một phần của **Systems Engineering** lớn hơn.
*   **Systems Engineering:** Quan tâm đến **tất cả 7 lớp** (từ Society đến Equipment). Họ quản lý sự phức tạp và tương tác giữa con người, quy trình và công nghệ.
*   **Software Engineering:** Tập trung vào các lớp **Software** (Application, Communications, OS).

Ý nghĩa & ứng dụng thực tế:
*   **Quản lý Phạm vi (Scope):** Giúp xác định ranh giới và trách nhiệm của các nhóm kỹ sư.
*   **Phân tích Nguyên nhân gốc:** Hỏng hóc ở lớp 7 (Society) có thể lan xuống lớp 4 (Application system).

Gợi ý câu hỏi thi:
*   **Dễ:** Lớp nào trong STS Stack là nơi ứng dụng chính của phần mềm được triển khai? (Đáp án: Application system.)
*   **Trung bình:** Lớp nào là nơi chứa các quy trình liên quan đến cả con người và máy tính? (Đáp án: Business processes.)
*   **Khó:** Sự khác biệt về phạm vi giữa Systems Engineering và Software Engineering là gì theo sơ đồ này? (Đáp án: SE bao gồm các lớp Organization và Society (yếu tố phi kỹ thuật), trong khi SWE chủ yếu tập trung vào 4 lớp kỹ thuật phía dưới: Application system trở xuống.)

#### **Slide 20 & 21: Layers in the STS stack**

Giải thích chi tiết (dùng lời của giảng viên):
Đây là định nghĩa chi tiết của từng lớp. Hãy lưu ý các lớp trên cùng:
*   **Business processes:** Không chỉ là code mà là **Set of processes involving people and computer systems**.
*   **Society:** Bao gồm **Laws, regulation and culture**. Chính những yếu tố này gây ra sự thay đổi lớn nhất và khó kiểm soát nhất cho hệ thống.

Ý nghĩa & ứng dụng thực tế:
*   **Thiết kế cho sự thay đổi:** Khi thiết kế hệ thống, cần xem xét tính linh hoạt để thích nghi với sự thay đổi của luật pháp (Society) và quy trình (Business processes).

Gợi ý câu hỏi thi:
*   **Dễ:** Lớp nào trong STS Stack cung cấp "Middleware that provides access to remote systems and databases"? (Đáp án: Communications and data management.)
*   **Trung bình:** Giải thích tại sao "Laws, regulation and culture" (Society) được coi là một lớp trong mô hình hệ thống kỹ thuật-xã hội. (Đáp án: Vì chúng tạo ra các ràng buộc, yêu cầu và bối cảnh hoạt động mà toàn bộ hệ thống phải tuân thủ, ảnh hưởng trực tiếp đến thiết kế và hoạt động của hệ thống.)
*   **Khó:** Nếu một lỗ hổng bảo mật nghiêm trọng được phát hiện trong "Operating system", lỗi này có thể lan truyền và ảnh hưởng trực tiếp đến lớp nào tiếp theo, và thuộc tính Dependability nào bị ảnh hưởng? (Đáp án: Lớp Application systems; ảnh hưởng đến Security và Availability.)

#### **Slide 22: Holistic system design**

Giải thích chi tiết (dùng lời của giảng viên):
Đây là khái niệm **Thiết kế toàn diện**. Vì có sự tương tác giữa các lớp, nên **góc nhìn hệ thống (systems perspective)** là **thiết yếu** cho độ tin cậy.
*   **Contain failure:** Cần kiểm soát để hỏng hóc phần mềm không thoát ra khỏi các lớp kỹ thuật và gây hại ở lớp Quy trình hoặc Tổ chức.
*   **Understand fault propagation:** Phải hiểu lỗi từ lớp lân cận ảnh hưởng đến phần mềm như thế nào (ví dụ: lỗi cấu hình từ người vận hành).

Ý nghĩa & ứng dụng thực tế:
*   **Yêu cầu Ràng buộc:** Các yêu cầu an toàn, an ninh cần phải đặt ràng buộc không chỉ cho phần mềm mà cho cả quy trình vận hành.

Gợi ý câu hỏi thi:
*   **Dễ:** Khái niệm nào là thiết yếu cho độ tin cậy do có sự tương tác và phụ thuộc giữa các lớp? (Đáp án: A systems perspective (Góc nhìn hệ thống).)
*   **Trung bình:** Nêu một ví dụ về việc thay đổi ở lớp Society ripple (lan truyền) xuống lớp Application software. (Đáp án: Thay đổi quy định về thuế (Society/Regulation) dẫn đến thay đổi logic tính toán trong Business processes, và sau đó yêu cầu thay đổi Application software.)
*   **Khó:** "Contain software failures within the enclosing layers" nghĩa là gì trong bối cảnh STS Stack? (Đáp án: Thiết kế phần mềm và quy trình bảo vệ xung quanh nó để nếu phần mềm hỏng, hậu quả sẽ chỉ giới hạn trong phạm vi kỹ thuật mà không gây ra lỗi thảm khốc ở lớp Business processes hoặc Organization.)

#### **Slide 23, 24, 25: Regulation and compliance**

Giải thích chi tiết (dùng lời của giảng viên):
Các hệ thống quan trọng (Nuclear, ATC, Medical devices) là **Regulated systems** (Hệ thống được quy định). Để được phép hoạt động:
1.  Phải được **cơ quan quản lý bên ngoài (external regulator)** phê duyệt.
2.  Phải tạo ra một **Safety and dependability case (Hồ sơ an toàn và độ tin cậy)** mở rộng. Hồ sơ này chứng minh đã tuân thủ luật và quy định.
3.  Việc tạo tài liệu cho chứng nhận có thể **tốn kém tương đương** với việc phát triển hệ thống.

Ý nghĩa & ứng dụng thực tế:
*   **Phát triển dựa trên bằng chứng:** Các nhóm phát triển phải tập trung vào việc tạo ra *bằng chứng* (evidence) cho thấy hệ thống là đáng tin cậy.
*   **Chi phí ẩn:** Đánh giá chi phí phải tính cả chi phí tài liệu và quy trình chứng nhận.

Gợi ý câu hỏi thi:
*   **Dễ:** Hệ thống nào sau đây *thường* là hệ thống được quy định: a) Ứng dụng mạng xã hội; b) Hệ thống điều khiển không lưu. (Đáp án: Hệ thống điều khiển không lưu.)
*   **Trung bình:** Vai trò chính của cơ quan quản lý bên ngoài trong việc phát triển hệ thống quan trọng là gì? (Đáp án: Phê duyệt việc sử dụng hệ thống và đánh giá Hồ sơ an toàn và độ tin cậy (Safety and dependability case).)
*   **Khó:** Tại sao "Regulation and compliance" áp dụng cho *sociotechnical system as a whole* thay vì chỉ riêng phần mềm? (Đáp án: Vì Safety (an toàn) và Security bị ảnh hưởng bởi lỗi con người, quy trình, và môi trường (các lớp STS Stack), không chỉ riêng code, do đó quy định phải bao quát toàn bộ hệ thống.)

---

### **Phần 4: Dư thừa và Đa dạng (Redundancy and Diversity)**

#### **Slide 27: Redundancy and diversity**

Giải thích chi tiết (dùng lời của giảng viên):
Hai kỹ thuật cốt lõi để đạt được **Fault Tolerance** (chịu lỗi):
1.  **Redundancy (Dư thừa):** Là **Backup** - có nhiều phiên bản **giống nhau** để thay thế nếu một cái hỏng. (Thường dùng cho Hardware failure).
2.  **Diversity (Đa dạng):** Là **Cách làm khác nhau** - nhiều phiên bản có cùng chức năng nhưng được triển khai bằng **nhiều cách khác nhau** (ngôn ngữ, thuật toán, nền tảng). Mục tiêu là tránh **common-mode failures** (Lỗi chế độ chung), tức là lỗi xảy ra do một nguyên nhân chung làm hỏng *tất cả* các thành phần.

Ý nghĩa & ứng dụng thực tế:
*   **Thiết kế chịu lỗi:** R&D là nền tảng cho các kiến trúc chịu lỗi như TMR (Triple Modular Redundancy).
*   **Ngăn ngừa Common-mode:** Đây là mục tiêu chính của Diversity.

Gợi ý câu hỏi thi:
*   **Dễ:** Mục đích của Diversity là gì? (Đáp án: Tránh Common-mode failures.)
*   **Trung bình:** Kỹ thuật nào sau đây là Redundancy: a) Triển khai hệ thống trên cả Linux và Windows; b) Chạy 3 phiên bản code giống hệt nhau trên 3 máy tính. (Đáp án: b) Chạy 3 phiên bản code giống hệt nhau trên 3 máy tính.)
*   **Khó:** Tại sao các thành phần dư thừa và đa dạng cần phải **độc lập (independent)**? (Đáp án: Để đảm bảo rằng một lỗi duy nhất (ví dụ: lỗi compiler, lỗi thiết kế logic) không dẫn đến Common-mode failure, làm hỏng tất cả các phiên bản.)

#### **Slide 28: Diversity and redundancy examples**

Giải thích chi tiết (dùng lời của giảng viên):
*   **Redundancy $\rightarrow$ Availability:** Máy chủ dự phòng giúp hệ thống luôn sẵn sàng.
*   **Diversity $\rightarrow$ Resilience:** Dùng nhiều HĐH (Windows, Linux) chống lại tấn công mạng hoặc lỗ hổng HĐH cụ thể (chỉ ảnh hưởng đến một loại HĐH).

Ý nghĩa & ứng dụng thực tế:
*   **Lựa chọn chiến lược:** Redundancy nên được dùng khi Availability là yêu cầu cao nhất; Diversity khi Resilience hoặc Safety là yêu cầu cao nhất.

Gợi ý câu hỏi thi:
*   **Dễ:** Việc sử dụng backup servers trong e-commerce là ví dụ cho kỹ thuật nào? (Đáp án: Redundancy.)
*   **Trung bình:** Việc sử dụng các HĐH khác nhau (Windows/Linux) trên các server phục vụ mục đích gì? (Đáp án: Diversity, tăng Resilience chống lại tấn công bên ngoài.)
*   **Khó:** Nếu một hệ thống kiểm soát bay sử dụng hai phiên bản phần mềm được viết bằng hai ngôn ngữ khác nhau, nó đang ưu tiên thuộc tính Dependability nào? (Đáp án: Safety/Reliability, bằng cách sử dụng Diversity để tránh lỗi logic thiết kế chung (common-mode failure).)

#### **Slide 29: Process diversity and redundancy**

Giải thích chi tiết (dùng lời của giảng viên):
Khái niệm R&D không chỉ áp dụng cho code/hardware mà còn cho **Quy trình (Process)**.
*   Thay vì chỉ dựa vào Testing (validation), nên sử dụng nhiều hoạt động V&V khác nhau (ví dụ: Reviews, Static Analysis, Testing).
*   Các hoạt động này bổ sung cho nhau (**cross-checking**) để tránh lỗi quy trình, từ đó tránh lỗi phần mềm.

Ý nghĩa & ứng dụng thực tế:
*   **Thiết kế quy trình V&V:** Các quy trình phát triển đáng tin cậy phải đa dạng hóa các kỹ thuật kiểm tra.

Gợi ý câu hỏi thi:
*   **Dễ:** Việc sử dụng các hoạt động V&V khác nhau trong quy trình nhằm mục đích gì? (Đáp án: Process diversity/redundancy, giúp kiểm tra chéo và tránh lỗi quy trình.)
*   **Trung bình:** Tại sao không nên chỉ dựa vào Testing để validate hệ thống? (Đáp án: Vì testing là một kỹ thuật V&V đơn lẻ, việc đa dạng hóa (ví dụ: thêm inspection, static analysis) giúp kiểm tra chéo và phát hiện lỗi mà testing có thể bỏ sót.)
*   **Khó:** Việc sử dụng **Design inspection** (kiểm tra thiết kế) và **Testing** (kiểm tra thực thi) đồng thời là ví dụ cho kỹ thuật gì? (Đáp án: Process Diversity, vì chúng bổ sung cho nhau (một kiểm tra tài liệu, một kiểm tra hành vi).)

#### **Slide 30: Problems with redundancy and diversity**

Giải thích chi tiết (dùng lời của giảng viên):
R&D không phải là viên đạn bạc. Nó có chi phí và rủi ro:
1.  **Tăng độ phức tạp:** Thêm các thành phần và cơ chế đồng bộ hóa chúng.
2.  **Tăng nguy cơ lỗi tương tác:** Lỗi có thể xảy ra do tương tác và phụ thuộc *không lường trước* giữa các thành phần dư thừa.

Ý nghĩa & ứng dụng thực tế:
*   **Triết lý Simplicity:** Một số kỹ sư ủng hộ **đơn giản (simplicity)** và **V&V mở rộng** như một cách hiệu quả hơn để đạt độ tin cậy.

Gợi ý câu hỏi thi:
*   **Dễ:** Vấn đề chính mà R&D gây ra cho hệ thống là gì? (Đáp án: Tăng độ phức tạp của hệ thống.)
*   **Trung bình:** Tại sao sự gia tăng độ phức tạp do R&D lại làm tăng nguy cơ lỗi? (Đáp án: Do tăng khả năng xảy ra *tương tác và phụ thuộc không lường trước* giữa các thành phần dư thừa.)
*   **Khó:** Lỗi tương tác không lường trước do R&D gây ra có thể dẫn đến loại lỗi nào, ngay cả khi các thành phần riêng lẻ đều hoạt động đúng? (Đáp án: Common-mode failure (nếu cơ chế đồng bộ hóa/bầu chọn bị lỗi) hoặc Reliability failure (do hệ thống đưa ra quyết định sai từ các thành phần không nhất quán).)

---

### **Phần 5: Quy trình Đáng tin cậy (Dependable Processes)**

#### **Slide 32: Dependable processes**

Giải thích chi tiết (dùng lời của giảng viên):
Để giảm thiểu lỗi phần mềm (**minimal number of software faults**), cần có quy trình:
1.  **Well-defined, repeatable (Xác định rõ ràng, có thể lặp lại):** Không phụ thuộc vào kỹ năng của cá nhân, mà có thể thực hiện bởi nhiều người khác nhau.
2.  **Regulators check:** Cơ quan quản lý sẽ kiểm tra quy trình để đảm bảo thực hành SE tốt.
3.  **Significant V&V:** Cần đầu tư lớn vào Kiểm chứng và Thẩm định (V&V).

Ý nghĩa & ứng dụng thực tế:
*   **Chứng minh tuân thủ:** Quy trình lặp lại được là bằng chứng cho regulator.
*   **Chất lượng nhất quán:** Giúp đảm bảo chất lượng không bị thay đổi theo từng dự án hoặc từng lập trình viên.

Gợi ý câu hỏi thi:
*   **Dễ:** Để đảm bảo một quy trình không phụ thuộc hoàn toàn vào kỹ năng cá nhân, nó cần có đặc điểm gì? (Đáp án: Repeatable (Có thể lặp lại).)
*   **Trung bình:** Tại sao việc đầu tư "significant effort" vào V&V lại là yêu cầu cốt lõi của quy trình đáng tin cậy? (Đáp án: Vì V&V là cơ chế chính để *phát hiện lỗi còn sót lại* (residual errors) trong hệ thống.)
*   **Khó:** Phân tích: Sự khác biệt giữa một quy trình "Ad-hoc" và một quy trình "Repeatable" trong việc giảm thiểu lỗi phần mềm là gì? (Đáp án: Ad-hoc phụ thuộc vào cá nhân và khó đo lường; Repeatable đảm bảo tính nhất quán của chất lượng bất kể ai thực hiện, do đó hiệu quả hơn trong việc giảm lỗi.)

#### **Slide 33: Dependable process characteristics**

Giải thích chi tiết (dùng lời của giảng viên):
*   **Explicitly defined (Định nghĩa rõ ràng):** Cần có **Defined process model** và **Data** thu thập được phải chứng minh nhóm đã làm theo mô hình đó.
*   **Repeatable (Lặp lại được):** Không dựa vào **Individual interpretation and judgment**.

Ý nghĩa & ứng dụng thực tế:
*   Là nền tảng của các mô hình đánh giá năng lực quy trình (ví dụ: CMMI).

Gợi ý câu hỏi thi:
*   **Dễ:** Đặc điểm nào của quy trình đòi hỏi phải thu thập dữ liệu để chứng minh sự tuân thủ? (Đáp án: Explicitly defined.)
*   **Trung bình:** Giải thích tầm quan trọng của việc không dựa vào "individual interpretation and judgment" đối với tính Repeatable. (Đáp án: Đảm bảo tính nhất quán của sản phẩm và chất lượng quy trình trên các dự án và đội nhóm khác nhau.)
*   **Khó:** Trong một quy trình Explicitly defined, dữ liệu được thu thập có vai trò gì ngoài việc chứng minh sự tuân thủ? (Đáp án: Được sử dụng để phân tích và cải tiến quy trình (Process Improvement), ví dụ: xác định bước nào tốn thời gian nhất hoặc dễ gây lỗi nhất.)

#### **Slide 34: Attributes of dependable processes (Table)**

Giải thích chi tiết (dùng lời của giảng viên):
Đây là danh sách chi tiết các thuộc tính để đánh giá một quy trình:
*   **Auditable (Kiểm toán được):** Người ngoài có thể hiểu.
*   **Diverse (Đa dạng):** Đã đề cập ở Slide 29 (R&D trong V&V).
*   **Documentable (Tài liệu hóa được):** Có mô hình và đầu ra.
*   **Robust (Vững chắc):** Khả năng phục hồi sau **thất bại quy trình** (ví dụ: một hoạt động review bị bỏ qua, quy trình có cơ chế bù đắp).
*   **Standardized (Tiêu chuẩn hóa):** Có bộ tiêu chuẩn phát triển toàn diện.

Ý nghĩa & ứng dụng thực tế:
*   **Checklist đánh giá:** Dùng để đánh giá một quy trình phát triển có đủ độ chín (maturity) cho hệ thống quan trọng hay không.

Gợi ý câu hỏi thi:
*   **Dễ:** Thuộc tính nào đòi hỏi phải có một bộ tiêu chuẩn phát triển phần mềm toàn diện? (Đáp án: Standardized.)
*   **Trung bình:** Nếu một hoạt động V&V thất bại (ví dụ: một buổi testing bị hủy), thuộc tính nào đảm bảo quy trình vẫn có thể tiếp tục và bù đắp? (Đáp án: Robust.)
*   **Khó:** Giải thích mối liên hệ giữa Auditable và Documentable. (Đáp án: Documentable tạo ra các tài liệu; Auditable là khả năng người ngoài hiểu các tài liệu đó và kiểm tra xem các tiêu chuẩn có được tuân thủ hay không.)

#### **Slide 35 & 36: Dependable process activities**

Giải thích chi tiết (dùng lời của giảng viên):
Đây là các hoạt động V&V cụ thể:
*   **Formal specification:** Sử dụng mô hình toán học để *phân tích* (Avoidance).
*   **System modeling:** Dùng mô hình đồ họa (UML, v.v.) và tài liệu hóa liên kết với yêu cầu.
*   **Design and program inspections:** Kiểm tra thủ công bởi **different people** (rất quan trọng cho việc *phát hiện* lỗi).
*   **Static analysis:** Kiểm tra tự động code mà không chạy nó.
*   **Test planning and management:** Phải chứng minh **coverage** (độ phủ) của yêu cầu.

Ý nghĩa & ứng dụng thực tế:
*   **Bằng chứng V&V:** Đây là các bằng chứng được thu thập trong Safety Case.

Gợi ý câu hỏi thi:
*   **Dễ:** Hoạt động nào liên quan đến việc kiểm tra tự động mã nguồn mà không cần chạy chương trình? (Đáp án: Static analysis.)
*   **Trung bình:** Vai trò của Requirements reviews là gì trong việc đạt độ tin cậy? (Đáp án: Check that requirements are complete and consistent (tránh đưa vào lỗi đặc tả).)
*   **Khó:** Phân tích: Tại sao "Design and program inspections" lại được coi là một hoạt động hiệu quả để đạt độ tin cậy? (Đáp án: Vì nó sử dụng nhiều người để kiểm tra chéo (diversity) trên các mô tả hệ thống khác nhau (thiết kế, code), giúp phát hiện lỗi logic mà testing có thể bỏ qua.)

#### **Slide 37 & 38: Dependable processes and agility**

Giải thích chi tiết (dùng lời của giảng viên):
Đây là một **xung đột then chốt** giữa triết lý:
*   **Dependable (Yêu cầu Chứng nhận):** Cần **tài liệu** đầy đủ và **phân tích yêu cầu từ đầu (Up-front analysis)** để đảm bảo Safety/Security.
*   **Agile (Yêu cầu Nhanh nhẹn):** Ưu tiên co-development, thay đổi nhanh, **tối thiểu hóa tài liệu**.

Kết luận (Slide 38): **"Pure agile" là impractical** cho Dependable systems engineering. Cần một **quy trình Agile có sửa đổi** (kết hợp iterative dev, test-first) nhưng phải **bổ sung documentation and planning** đầy đủ.

Ý nghĩa & ứng dụng thực tế:
*   **Lựa chọn mô hình phát triển:** Phải chọn mô hình phát triển lai (hybrid) cho các hệ thống quan trọng.

Gợi ý câu hỏi thi:
*   **Dễ:** Điều gì trong phát triển Dependable systems xung đột trực tiếp với việc "minimizing documentation" của Agile? (Đáp án: Yêu cầu chứng nhận (certification).)
*   **Trung bình:** Tại sao "Up-front requirements analysis" là thiết yếu cho Dependable systems nhưng lại xung đột với triết lý Agile? (Đáp án: Thiết yếu vì cần khám phá xung đột yêu cầu Safety/Security sớm; xung đột vì Agile ưu tiên co-development yêu cầu và hệ thống (phát triển yêu cầu dần dần).)
*   **Khó:** Trình bày những gì là **bắt buộc** phải thêm vào một quy trình Agile để nó có thể được sử dụng cho Dependable systems engineering. (Đáp án: Phải thêm *tài liệu quy trình và sản phẩm* đầy đủ, và *lập kế hoạch/phân tích yêu cầu từ đầu* (Up-front analysis).)

---

### **Phần 6: Phương pháp Hình thức và Độ tin cậy (Formal methods)**

#### **Slide 40, 41: Formal methods and dependability**

Giải thích chi tiết (dùng lời của giảng viên):
**Formal Methods (FM)** dựa trên **biểu diễn toán học (mathematical representation)**.
*   **FM bao gồm:** Đặc tả hình thức, Phân tích/Chứng minh, Phát triển chuyển đổi (Transformational development), Xác minh chương trình.
*   **Lợi ích:** Giảm đáng kể một số loại lỗi lập trình (Avoidance).
*   **Hai cách tiếp cận:**
    *   **Verification-based:** Chứng minh đặc tả và chương trình là **equivalent** (chứng minh code không có lỗi so với spec).
    *   **Refinement-based:** Chuyển đổi **tự động** (hoặc có hệ thống) từ spec cấp cao xuống code cấp thấp.

Ý nghĩa & ứng dụng thực tế:
*   **Công cụ tránh lỗi:** FM là một công cụ mạnh mẽ trong giai đoạn Avoidance của Dependability achievement.

Gợi ý câu hỏi thi:
*   **Dễ:** Phương pháp hình thức dựa trên cơ sở nào? (Đáp án: Mathematical representation and analysis of software.)
*   **Trung bình:** Phương pháp nào nhằm mục đích chứng minh rằng một đặc tả và một chương trình cài đặt đặc tả đó là tương đương? (Đáp án: Verification-based approaches.)
*   **Khó:** Phân tích: Tại sao Refinement-based approaches (chuyển đổi tự động) được coi là một cách hiệu quả hơn để đảm bảo tính đúng đắn? (Đáp án: Vì nếu quá trình chuyển đổi là đúng, nó có thể loại bỏ lỗi cài đặt do con người gây ra.)

#### **Slide 42: Use of formal methods**

Giải thích chi tiết (dùng lời của giảng viên):
FM tập trung vào việc **giảm số lượng lỗi** (faults) và được áp dụng hiệu quả nhất ở lĩnh vực **Dependable systems engineering** vì ở đó **high system failure costs must be avoided**.

Ý nghĩa & ứng dụng thực tế:
*   **Justification:** FM được sử dụng chủ yếu trong ngành hàng không, hạt nhân, và y tế.

Gợi ý câu hỏi thi:
*   **Dễ:** Lợi ích chính của Formal Methods là gì? (Đáp án: Giảm số lượng faults trong hệ thống.)
*   **Trung bình:** Khu vực áp dụng chính của Formal Methods là gì và tại sao? (Đáp án: Dependable systems engineering, vì FM giúp tránh lỗi và chi phí hỏng hóc cao cần phải được tránh.)
*   **Khó:** Liên hệ: Việc sử dụng Formal Methods có thể giúp giảm chi phí Dependability theo thời gian, dù chi phí ban đầu cao. Tại sao? (Đáp án: Vì FM giúp *tránh* lỗi và *giảm* chi phí kiểm thử, tránh được chi phí thất bại thảm khốc sau này.)

#### **Slide 44: Benefits of formal specification**

Giải thích chi tiết (dùng lời của giảng viên):
Lợi ích của **Formal Specification** (việc tạo ra đặc tả):
1.  **Phân tích chi tiết Yêu cầu:** Giúp phát hiện **problems, inconsistencies and incompleteness** (Avoidance).
2.  **Phân tích tự động:** Đặc tả viết bằng ngôn ngữ hình thức có thể được công cụ tự động kiểm tra.

Ý nghĩa & ứng dụng thực tế:
*   **Lợi ích kép:** Vừa là công cụ phát triển yêu cầu tốt, vừa là công cụ phát triển code tốt.

Gợi ý câu hỏi thi:
*   **Dễ:** Lợi ích nào của đặc tả hình thức giúp phát hiện mâu thuẫn trong yêu cầu? (Đáp án: As the specification is expressed in a formal language, it can be automatically analyzed.)
*   **Trung bình:** Việc phát triển đặc tả hình thức đóng góp vào giai đoạn đạt độ tin cậy nào? (Đáp án: Avoid the introduction of accidental errors when developing the system.)
*   **Khó:** Tại sao chi phí kiểm thử chương trình có thể được giảm nếu chương trình được xác minh hình thức (formally verified)? (Đáp án: Vì việc xác minh hình thức chứng minh tính đúng đắn của code so với spec, giúp loại bỏ nhu cầu cho một số loại kiểm thử để phát hiện lỗi.)

#### **Slide 45: Acceptance of formal methods**

Giải thích chi tiết (dùng lời của giảng viên):
Đây là slide giải thích tại sao FM lại có **limited impact** (tác động hạn chế) trong thực tế:
1.  **Vấn đề hiểu biết:** Chủ sở hữu vấn đề (business owners) **không hiểu** spec hình thức.
2.  **Vấn đề kinh tế:** Khó đánh giá **lợi ích** (lỗi được tránh).
3.  **Vấn đề văn hóa:** Kỹ sư phần mềm **không quen thuộc**.
4.  **Vấn đề kỹ thuật:** Khó **scale up** cho hệ thống lớn.
5.  **Vấn đề quy trình:** **Không tương thích** với Agile.

Ý nghĩa & ứng dụng thực tế:
*   **Thực tế khắc nghiệt:** FM chỉ nên được sử dụng khi lợi ích an toàn/an ninh vượt trội hơn tất cả các hạn chế này.

Gợi ý câu hỏi thi:
*   **Dễ:** Nêu một lý do khiến Formal Methods không được chấp nhận rộng rãi. (Đáp án: Formal specification is not really compatible with agile development methods.)
*   **Trung bình:** Giải thích tại sao quản lý có thể không sẵn lòng đầu tư vào FM. (Đáp án: Vì dễ đánh giá chi phí nhưng khó đánh giá lợi ích (lỗi được tránh), khiến ROI không rõ ràng.)
*   **Khó:** Phân tích: Lý do nào khiến FM khó scale up và không tương thích với Agile có mối liên hệ như thế nào? (Đáp án: Các hệ thống lớn thường được phát triển bằng Agile. Việc FM khó scale up và không tương thích Agile khiến nó bị loại khỏi các dự án phát triển hệ thống lớn hiện đại.)