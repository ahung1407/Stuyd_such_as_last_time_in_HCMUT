Chào bạn, tiếp nối hai đề trước, tôi xin thiết kế **Đề thi số 3**.

Đề thi này sẽ có cấu trúc **khó hơn một chút về mặt kỹ thuật lập trình**, tập trung vào các chủ đề quan trọng còn lại như: **Tối ưu hóa C (Bit manipulation, Pointers)**, **Giao thức Bus (Bus Timing/Arbitration)**, và bài toán thiết kế **Hệ thống Đèn giao thông** (được nhắc đến kỹ trong Lecture 4).

---

# ĐỀ THI CUỐI KỲ MẪU SỐ 3: HỆ THỐNG NHÚNG (CO3053)

**Thời gian:** 90 phút
**Hình thức:** Tự luận (Sinh viên làm bài trên giấy thi)
**Tài liệu:** Được sử dụng 02 tờ A4 tài liệu tham khảo

---

## PHẦN I: TRẮC NGHIỆM & CÂU HỎI NGẮN (30 Điểm)

**Câu 1:** Trong quy tắc Debugging, chiến lược "Divide and Conquer" (Chia để trị) thực hiện như thế nào?
A. Thay thế toàn bộ phần cứng để loại trừ lỗi.
B. Chia nhỏ hệ thống hoặc code, cô lập các thành phần để thu hẹp phạm vi gây lỗi (ví dụ: ngắt cảm biến để xem lỗi do phần cứng hay phần mềm).
C. Nhờ nhiều người cùng debug một lúc.
D. Viết lại code từ đầu theo từng module nhỏ.
_(Gợi ý: Xem lại 9 quy tắc Debugging, Rule #4)_

**Câu 2:** Đặc điểm chính của phương thức định thời Bus "Asynchronous Timing" (Không đồng bộ) là gì?
A. Sử dụng chung một xung Clock toàn cục để đồng bộ hóa.
B. Tốc độ truyền dữ liệu luôn nhanh hơn phương thức Synchronous.
C. Sử dụng cơ chế bắt tay (Handshaking) thay vì xung Clock, cho phép kết nối các thiết bị có tốc độ khác nhau.
D. Dễ bị hiện tượng "Clock Skew" trên đường dây dài.
_(Gợi ý: Xem lại Bus Timing Scheme,)_

**Câu 3:** Trong lập trình C nhúng cho ARM, tại sao nên sử dụng kiểu dữ liệu `int` (32-bit) cho biến đếm vòng lặp thay vì `short` (16-bit) hay `char` (8-bit)?
A. Vì `int` tốn ít bộ nhớ RAM hơn.
B. Vì `int` là kích thước thanh ghi tự nhiên (native register size) của ARM, giúp vi xử lý không cần dùng thêm lệnh để mặt nạ (mask) hoặc xử lý dấu.
C. Vì `char` không thể đếm quá 100.
D. Vì `short` không được hỗ trợ bởi trình biên dịch C.
_(Gợi ý: Xem lại Efficient C Programming)_

**Câu 4:** (Câu hỏi ngắn) Hãy giải thích khái niệm **Memory Mapped I/O (MMIO)**. Tại sao trong bản đồ bộ nhớ (Memory Map), địa chỉ của các thiết bị ngoại vi (như Flash, Timer) lại nằm chung không gian với RAM?
_(Gợi ý: Xem lại slide System Memory Map,)_

**Câu 5:** Đoạn macro sau đây có vấn đề gì? Hãy viết lại cho đúng.
`#define MULT(a,b) (a * b)`
Giả sử gọi `MULT(1+2, 3)`. Kết quả thực tế và kết quả mong đợi là bao nhiêu?
_(Gợi ý: Lỗi ưu tiên toán tử trong Macro)_

**Câu 6:** Trong mô hình RTOS, cơ chế nào giúp giải quyết vấn đề "Priority Inversion" (Đảo ngược độ ưu tiên)?
A. Round-robin scheduling.
B. Priority Inheritance (Thừa kế độ ưu tiên).
C. Tắt toàn bộ ngắt (Disable interrupts).
D. Sử dụng Polling thay vì Interrupt.
_(Gợi ý: Xem lại sự cố Mars Pathfinder và giải pháp)_

---

## PHẦN II: TỰ LUẬN - THIẾT KẾ & LẬP TRÌNH (70 Điểm)

### Bài toán: Hệ Thống Đèn Giao Thông Ngã Tư Thông Minh (Smart Traffic Light)

Bạn hãy thiết kế hệ thống điều khiển đèn giao thông cho một ngã tư gồm 2 hướng: Bắc-Nam (NS) và Đông-Tây (WE).

- **Đầu ra:** Mỗi hướng có 3 đèn: Đỏ, Vàng, Xanh. (Tổng cộng 6 tín hiệu output: `NS_R`, `NS_Y`, `NS_G`, `WE_R`, `WE_Y`, `WE_G`).
- **Đầu vào:**
  - Mỗi hướng có 1 cảm biến phát hiện xe: `S_NS` (có xe hướng Bắc-Nam) và `S_WE` (có xe hướng Đông-Tây).
  - Một nút nhấn khẩn cấp `EMERGENCY`.

**Yêu cầu hoạt động:**

1.  **Chế độ bình thường:** Hệ thống hoạt động theo chu trình: NS Xanh -> NS Vàng -> NS Đỏ (đồng thời WE chuyển Xanh). Đảm bảo logic an toàn (không bao giờ cùng Xanh).
2.  **Chế độ tiết kiệm (Smart Mode):** Nếu `S_NS` báo có xe nhưng `S_WE` không có xe liên tục trong 1 phút, hướng NS sẽ giữ mãi đèn Xanh (ưu tiên dòng xe đang chạy) cho đến khi `S_WE` phát hiện có xe chờ.
3.  **Chế độ khẩn cấp:** Khi nhấn nút `EMERGENCY`, tất cả đèn Đỏ đều sáng ngay lập tức.

---

### Yêu cầu thực hiện:

**Câu 1 (15 điểm): Thiết kế Máy trạng thái (FSM)**
Vẽ biểu đồ máy trạng thái (State Machine Diagram) cho hệ thống.

- Xác định rõ các trạng thái chính: `NS_GO`, `NS_WAIT` (Vàng), `WE_GO`, `WE_WAIT` (Vàng), `EMERGENCY_STOP`.
- Thể hiện rõ các điều kiện chuyển đổi dựa trên Timer và Cảm biến (`S_NS`, `S_WE`).
- **Chú ý:** Cần thể hiện logic chuyển đổi từ Xanh sang Vàng rồi mới sang Đỏ để đảm bảo an toàn,.

**Câu 2 (20 điểm): Kỹ thuật thao tác Bit (Bit Manipulation)**
Giả sử cả 6 đèn được nối vào một thanh ghi Output 8-bit tên là `PORT_LIGHTS` tại địa chỉ `0x40005000`.
Các bit được quy định như sau:

- Bit 0: `NS_G`, Bit 1: `NS_Y`, Bit 2: `NS_R`.
- Bit 3: `WE_G`, Bit 4: `WE_Y`, Bit 5: `WE_R`.

a. Hãy viết dòng lệnh C khai báo con trỏ `pPort` trỏ tới thanh ghi này (sử dụng từ khóa `volatile` đúng cách).
b. Viết các dòng lệnh C (dùng phép toán bit `&`, `|`, `~`, `<<`) để thực hiện các hành động sau mà **không làm ảnh hưởng đến các bit khác** (như bit 6, 7):

- Trạng thái 1: Bật `NS_G` và `WE_R` (Các đèn khác tắt).
- Trạng thái 2: Chuyển `NS` từ Xanh sang Vàng (`NS_G` tắt, `NS_Y` bật), `WE` vẫn giữ Đỏ.

_(Gợi ý: Sử dụng mặt nạ bit - Bitmask)_

**Câu 3 (15 điểm): Mô hình lập trình & Ngắt**
Để xử lý sự kiện `EMERGENCY` một cách tức thời, bạn sẽ sử dụng phương pháp Polling (Hỏi vòng) hay Interrupt (Ngắt)?
a. Vẽ lưu đồ (Flowchart) cho trình phục vụ ngắt (ISR) của sự kiện `EMERGENCY`.
b. Phân tích một rủi ro "Shared-data" có thể xảy ra giữa chương trình chính (đang điều khiển đèn theo Timer) và ISR này. Làm sao để khắc phục?
_(Gợi ý: Xem lại Round Robin with Interrupts và Shared-data problems,)_

**Câu 4 (20 điểm): Giao tiếp Bus cảm biến**
Giả sử cảm biến `S_NS` và `S_WE` là loại cảm biến camera thông minh, giao tiếp với vi điều khiển qua chuẩn **I2C**.
a. Vẽ sơ đồ kết nối dây giữa Vi điều khiển (Master) và 2 cảm biến (Slaves). Chỉ rõ các đường dây tín hiệu cần thiết.
b. I2C hoạt động theo cơ chế địa chỉ (Address-based). Điều gì xảy ra nếu hai cảm biến này có cùng một địa chỉ I2C mặc định từ nhà sản xuất? Đề xuất 01 giải pháp phần cứng hoặc phần mềm để giải quyết.
_(Gợi ý: Xem lại lý thuyết về I2C Bus,)_

---

### HƯỚNG DẪN GIẢI & ĐÁP ÁN THAM KHẢO

**Phần I: Trắc nghiệm**

1.  **B:** Divide and Conquer là chia nhỏ hệ thống để cô lập lỗi,.
2.  **C:** Asynchronous dùng handshaking, không dùng clock chung,.
3.  **B:** `int` 32-bit là kích thước thanh ghi tự nhiên của ARM, xử lý nhanh nhất.
4.  **Trả lời:** MMIO là kỹ thuật ánh xạ thanh ghi ngoại vi vào cùng không gian địa chỉ với bộ nhớ. CPU dùng chung lệnh (Load/Store) để truy cập cả RAM và I/O, giúp đơn giản hóa tập lệnh,.
5.  **Trả lời:** Thiếu ngoặc đơn. `MULT(1+2, 3)` sẽ khai triển thành `1 + 2 * 3` = 7. Mong đợi là `(1+2)*3` = 9. Sửa: `#define MULT(a,b) ((a)*(b))`.
6.  **B:** Priority Inheritance.

**Phần II: Tự luận**

- **Câu 1 (FSM):**

  - Sinh viên cần vẽ trạng thái: `NS_GO` (NS xanh, WE đỏ) -> `NS_YELLOW` (NS vàng, WE đỏ) -> `WE_GO` (NS đỏ, WE xanh) -> `WE_YELLOW` -> quay lại `NS_GO`.
  - Logic Smart Mode: Tại `NS_GO`, nếu `Timer > Limit` VÀ `S_WE == 0` (không có xe hướng kia) -> Duy trì `NS_GO` (Self-loop) thay vì chuyển sang Vàng.
  - Trạng thái `EMERGENCY`: Từ mọi trạng thái, nếu nhấn nút -> chuyển ngay sang `EMERGENCY_STOP` (All Red).

- **Câu 2 (Bit Manipulation):**

  - a. `volatile unsigned char *pPort = (unsigned char *)0x40005000;`.
  - b. Trạng thái 1 (NS_G=1, WE_R=1, còn lại 0):
    `*pPort = (*pPort & 0xC0) | (1<<0) | (1<<5);` (Giữ bit 6,7; set bit 0, 5).
  - c. Trạng thái 2 (NS_G tắt, NS_Y bật):
    `*pPort &= ~(1<<0);` (Tắt bit 0 - Green).
    `*pPort |= (1<<1);` (Bật bit 1 - Yellow).

- **Câu 3 (Interrupt & Shared Data):**

  - Chọn **Interrupt** để phản hồi tức thì (Real-time).
  - Flowchart ISR: Start -> Set Flag `Emergency_Active = 1` -> Set All Outputs to RED -> End.
  - Rủi ro: Biến `Light_State` có thể bị corrupt nếu Main loop đang ghi dở thì ISR nhảy vào ghi đè. Khắc phục: Dùng từ khóa `volatile` cho biến cờ hoặc tắt ngắt (Atomic access) khi truy cập biến chia sẻ.

- **Câu 4 (I2C):**
  - Sơ đồ: 2 dây SDA, SCL nối chung, có điện trở kéo lên (Pull-up resistors). Master nối với 2 Slaves song song.
  - Trùng địa chỉ: Master không thể phân biệt 2 slave.
  - Giải pháp: Sử dụng bộ I2C Multiplexer (phần cứng) hoặc chọn loại cảm biến có chân cấu hình địa chỉ (Hardware Address Pin) để đổi địa chỉ 1 con sang giá trị khác.
