Chào bạn, tôi đã cập nhật lại **Đề thi mẫu số 4** dựa trên phản hồi quan trọng của bạn: **"Tập trung vào tư duy hệ thống, không yêu cầu viết Code/Macro"**.

Đề thi này được điều chỉnh để đánh vào **khả năng phân tích (Analysis)**, **thiết kế kiến trúc (System Design)** và **xử lý tình huống (Problem Solving)** – đúng theo tinh thần các Case Study trong Lecture 3 và 4.

---

# ĐỀ THI CUỐI KỲ MẪU SỐ 4 (REVISED): TƯ DUY THIẾT KẾ HỆ THỐNG

**Môn:** Hệ thống Nhúng (CO3053)
**Thời gian:** 90 phút
**Hình thức:** Trắc nghiệm (30%) + Tự luận Phân tích (70%)

---

## PHẦN I: TRẮC NGHIỆM & TÍNH TOÁN NHANH (30 Điểm)

**Câu 1:** Một Bus PCI hoạt động ở tần số 33 MHz với độ rộng dữ liệu 32-bit. Băng thông lý thuyết (Throughput) tối đa của Bus này là bao nhiêu?
A. 132 MB/s
B. 264 MB/s
C. 1056 MB/s
D. 66 MB/s
_(Gợi ý: Công thức $Throughput = Frequency \times (Width / 8)$)_

**Câu 2:** Trong mô hình trọng tài Bus "Central-serialized" (Daisy-chain), rủi ro lớn nhất về mặt độ tin cậy là gì?
A. Cần quá nhiều dây kết nối.
B. Nếu một thiết bị ở đầu chuỗi bị hỏng, các thiết bị phía sau sẽ mất quyền truy cập Bus.
C. Không hỗ trợ thiết bị Master.
D. Tốc độ truyền quá chậm.
_(Gợi ý: Xem lại cơ chế Daisy-chain trong Lecture 2)_

**Câu 3:** Tại sao bộ nhớ DRAM thường được dùng làm bộ nhớ chính (Main Memory) thay vì SRAM, mặc dù SRAM nhanh hơn?
A. Vì DRAM không cần làm tươi (refresh).
B. Vì DRAM rẻ hơn và có mật độ tích hợp cao hơn (nhiều GB hơn trên cùng diện tích).
C. Vì DRAM không mất dữ liệu khi mất điện.
D. Vì DRAM tiêu thụ ít điện năng hơn SRAM.
_(Gợi ý: So sánh Memory Types,)_

**Câu 4:** Trong quy trình phát triển, bước nào quyết định chức năng nào sẽ do phần cứng (FPGA/ASIC) đảm nhiệm và chức năng nào do phần mềm (CPU) đảm nhiệm?
A. Hardware-Software Partitioning (thuộc giai đoạn System Design).
B. Cross-compilation.
C. Requirements Gathering.
D. Unit Testing.
_(Gợi ý: Lecture 3)_

**Câu 5:** Đặc điểm nào của hệ thống nhúng "Hard Real-time" là đúng nhất?
A. Hệ thống phải chạy càng nhanh càng tốt.
B. Việc bỏ lỡ hạn chót (deadline) được coi là lỗi hệ thống toàn diện (thảm họa).
C. Hệ thống không bao giờ dùng pin.
D. Ưu tiên giao diện người dùng đẹp.
_(Gợi ý: Định nghĩa Real-time)_

**Câu 6:** (Câu hỏi ngắn) Tại sao cảm biến trong xe hơi thường sử dụng giao thức CAN (Distributed Arbitration) thay vì mô hình trọng tài trung tâm (Central Arbitration)?
_(Gợi ý: Liên quan đến độ tin cậy khi bộ điều khiển trung tâm bị hỏng)_

---

## PHẦN II: TỰ LUẬN - TƯ DUY THIẾT KẾ (70 Điểm)

### Câu 1: Tư duy Phân tích Kiến trúc - Case Study ECU (25 điểm)

Dựa trên bài toán thiết kế bộ điều khiển động cơ (ECU) để điều khiển thời điểm phun xăng và đánh lửa (Lecture 3):

**Tình huống:** Kỹ sư A đề xuất sử dụng **Phương án 1**: Dùng duy nhất một vi xử lý 32-bit mạnh mẽ để vừa tính toán lượng khí nạp (dựa trên cảm biến) vừa trực tiếp điều khiển xung kích hoạt Bugi (Actuators).

**Yêu cầu:**

1.  **Phân tích rủi ro:** Tại sao phương án này có nguy cơ thất bại về mặt "Real-time constraints" (Ràng buộc thời gian thực)? Điều gì xảy ra nếu CPU đang bận tính toán phép nhân số thực phức tạp của luồng khí nạp đúng lúc cần đánh lửa?
2.  **Đề xuất giải pháp (Option 2):** Vẽ sơ đồ khối kiến trúc kết hợp giữa **CPU** và **FPGA**. Phân tích vai trò cụ thể của từng khối trong kiến trúc mới này để giải quyết vấn đề trên. (Gợi ý: Khối nào tính toán? Khối nào kích xung?).
3.  **So sánh:** Đây là ví dụ của kỹ thuật gì trong quy trình thiết kế hệ thống? (Hardware-Software Partitioning).

### Câu 2: Tư duy Logic Máy trạng thái - Cửa Cuốn Tự Động (25 điểm)

Xét hệ thống điều khiển cửa cuốn Garage với 2 nút nhấn (UP, DOWN) và 2 cảm biến hành trình (Sensor_Open, Sensor_Closed).

**Tình huống:** Một sinh viên thiết kế máy trạng thái chỉ có 2 trạng thái: `OPENED` và `CLOSED`.

- Nếu đang `CLOSED` nhấn UP $\rightarrow$ chuyển ngay sang `OPENED`.
- Nếu đang `OPENED` nhấn DOWN $\rightarrow$ chuyển ngay sang `CLOSED`.

**Yêu cầu:**

1.  **Phản biện:** Tại sao thiết kế trên là **sai thực tế** và không thể hoạt động an toàn với một động cơ vật lý? (Gợi ý: Động cơ cần thời gian di chuyển),.
2.  **Thiết kế lại:** Hãy vẽ lại máy trạng thái đúng, bổ sung các **trạng thái trung gian (Transient States)**.
    - Gọi tên chính xác các trạng thái trung gian này.
    - Xác định điều kiện chuyển đổi (Transition Conditions) dựa trên tín hiệu Cảm biến và Nút nhấn.
3.  **Xử lý sự cố:** Bổ sung logic cho trường hợp: Cửa đang đóng (`CLOSING`), người dùng thấy vật cản và nhấn nút UP. Hệ thống phải phản ứng thế nào để đảm bảo an toàn? Vẽ đường chuyển đổi này vào sơ đồ.

### Câu 3: Tư duy Hệ điều hành & Đa nhiệm (20 điểm)

Hệ thống điều khiển Robot thám hiểm sao Hỏa (Mars Pathfinder) gặp một lỗi kinh điển liên quan đến **Priority Inversion** (Đảo ngược độ ưu tiên).

**Yêu cầu:**

1.  **Giải thích hiện tượng:** Sử dụng 3 tác vụ giả định: `Task High` (Gửi dữ liệu về Trái Đất), `Task Medium` (Xử lý ảnh), `Task Low` (Thu thập thời tiết) và một tài nguyên chia sẻ (Mutex) để giải thích tại sao `Task High` lại bị chặn bởi `Task Medium`. (Không cần viết code, hãy mô tả bằng lời hoặc sơ đồ thời gian).
2.  **Giải pháp:** Tên của giải pháp kỹ thuật để khắc phục vấn đề này là gì? Nguyên lý hoạt động cơ bản của nó? (Gợi ý: Khi Task High chờ, chuyện gì xảy ra với độ ưu tiên của Task Low?).
3.  **Lựa chọn mô hình:** Đối với hệ thống phanh ABS của ô tô, bạn sẽ chọn mô hình lập trình "Round-robin" hay "RTOS"? Tại sao? (Dựa trên tính đoán định/Determinism).

---

### HƯỚNG DẪN TRẢ LỜI (KEY POINTS) - Dành cho ôn tập

**Câu 1 (ECU):**

- _Rủi ro Opt 1:_ CPU xử lý tuần tự. Nếu tính toán khí nạp (Math heavy) mất quá nhiều thời gian, CPU sẽ trễ nhịp kích hoạt Bugi $\rightarrow$ Động cơ bị rung, sai thời điểm nổ, ô nhiễm môi trường.
- _Giải pháp Opt 2:_ CPU (16-bit) tính toán logic + FPGA điều khiển Actuators. FPGA chạy song song (Hardware parallelism), đảm bảo kích xung chính xác từng micro-giây bất kể CPU đang làm gì.

**Câu 2 (Cửa cuốn):**

- _Sai lầm:_ Cửa không thể dịch chuyển tức thời (Teleport) từ Đóng sang Mở. Cần thời gian chạy motor.
- _Thiết kế đúng:_ Phải có trạng thái `OPENING` (Đang mở) và `CLOSING` (Đang đóng).
- _Logic:_ `CLOSED` $\xrightarrow{Press UP}$ `OPENING` $\xrightarrow{Sensor Open}$ `OPENED`.
- _An toàn:_ Từ `CLOSING` $\xrightarrow{Press UP}$ `OPENING` (Đảo chiều ngay lập tức) hoặc về trạng thái dừng lơ lửng `HALF-OPEN`.

**Câu 3 (Priority Inversion):**

- _Hiện tượng:_ Task Low giữ chìa khóa (Mutex). Task High cần chìa khóa nên phải chờ (Blocked). Task Medium (không cần khóa) chiếm quyền CPU của Task Low $\rightarrow$ Task Low không chạy được để trả khóa $\rightarrow$ Task High chờ vô hạn Task Medium.
- _Giải pháp:_ **Priority Inheritance Protocol**. Khi High chờ Low, hệ điều hành tạm thời nâng độ ưu tiên của Low lên bằng High để nó chạy nhanh, trả khóa, rồi về lại ưu tiên cũ.
